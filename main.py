#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import sys
import subprocess
import threading
import zipfile
import shutil
import traceback
import time
import socket
from datetime import datetime
import platform
import base64
import io

def get_hidden_startupinfo():
    """Создает startupinfo для скрытия консольного окна в Windows"""
    startupinfo = None
    if platform.system() == "Windows":
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        startupinfo.wShowWindow = subprocess.SW_HIDE
    return startupinfo
base64_string = """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"""
base64_qrico = """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"""

def ensure_npm_cli(node_dir, logger=None):
    """
    Ensure npm-cli.js exists inside provided embedded node_dir.
    If absent, attempt to download and extract npm into node_dir/node_modules/npm.
    Returns the path to npm-cli.js (may not exist if bootstrap failed).
    """
    import os, urllib.request, io, tarfile
    try:
        candidates = [
            os.path.join(node_dir, "node_modules", "npm", "bin", "npm-cli.js"),
            os.path.join(node_dir, "lib", "node_modules", "npm", "bin", "npm-cli.js"),
            os.path.join(node_dir, "npm-cli.js"),
            os.path.join(node_dir, "bin", "npm-cli.js"),
        ]
        for p in candidates:
            if os.path.exists(p):
                return p
        try:
            if logger: logger.log("npm not found in embedded Node — downloading npm package...", "WARNING")
            npm_tgz_url = "https://registry.npmjs.org/npm/-/npm-10.8.2.tgz"
            with urllib.request.urlopen(npm_tgz_url, timeout=30) as resp:
                data = resp.read()
            tf = tarfile.open(fileobj=io.BytesIO(data), mode="r:gz")
            dest = os.path.join(node_dir, "node_modules", "npm")
            os.makedirs(dest, exist_ok=True)
            prefix = "package/"
            for member in tf.getmembers():
                name = member.name
                if name.startswith(prefix):
                    member.name = name[len(prefix):]
                else:
                    member.name = name
                if member.name in ("", "."):
                    continue
                try:
                    tf.extract(member, path=dest)
                except Exception:
                    continue
            cli = os.path.join(dest, "bin", "npm-cli.js")
            if os.path.exists(cli):
                if logger: logger.log(f"Bootstrapped npm to {cli}", "SUCCESS")
                return cli
        except Exception as e:
            if logger: logger.log(f"Failed to bootstrap npm: {e}", "ERROR")
    except Exception:
        pass
    return os.path.join(node_dir, "node_modules", "npm", "bin", "npm-cli.js")

# GUI library
try:
    import customtkinter as ctk
except Exception:
    print("Please install customtkinter: pip install customtkinter")
    sys.exit(1)
import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk, simpledialog

# Image handling
try:
    from PIL import Image, ImageTk
except Exception:
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "Pillow"], startupinfo=get_hidden_startupinfo())
        from PIL import Image, ImageTk
    except Exception:
        Image = None
        ImageTk = None
# HTTP
try:
    import requests
except Exception:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "requests"], startupinfo=get_hidden_startupinfo())
    import requests
# clipboard
try:
    import pyperclip
except Exception:
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "pyperclip"], startupinfo=get_hidden_startupinfo())
        import pyperclip
    except Exception:
        class _PyperclipStub:
            @staticmethod
            def copy(text):
                print("pyperclip not installed; cannot copy.")
        pyperclip = _PyperclipStub()
# Process handling for cleanup
try:
    import psutil
except Exception:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "psutil"], startupinfo=get_hidden_startupinfo())
    import psutil
# ------------------------
# Utilities
# ------------------------
def get_hidden_startupinfo():
    """Создает startupinfo для скрытия консольного окна в Windows"""
    startupinfo = None
    if platform.system() == "Windows":
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        startupinfo.wShowWindow = subprocess.SW_HIDE
    return startupinfo

def safe_makedirs(path):
    try:
        os.makedirs(path, exist_ok=True)
    except Exception as e:
        print(f"Failed to create directory {path}: {e}")
def human_size(num):
    try:
        n = float(num)
    except Exception:
        return "?"
    for unit in ("Б", "КБ", "МБ", "ГБ", "ТБ"):
        if n < 1024.0:
            return f"{n:3.1f}{unit}"
        n /= 1024.0
    return f"{n:.1f}ПБ"
def kill_processes_by_name(name):
    for proc in psutil.process_iter(['pid', 'name']):
        try:
            if name.lower() in (proc.info.get('name') or "").lower():
                proc.terminate()
                proc.wait(timeout=3)
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass

# ------------------------
# Translations (EN -> RU)
# ------------------------
TRANSLATIONS = {
    "Project type:": "Тип проекта:",
    "Load Project": "Загрузить проект",
    "Build:": "Тип сборки:",
    "⚡ Build": "⚡ Собрать",
    "No project loaded": "Проект не загружен",
    "Keystore (for signed builds):": "Keystore (для подписанных сборок):",
    "Not selected": "Не выбран",
    "Select Keystore": "Выбрать Keystore",
    "Create Keystore": "Создать Keystore",
    "Choose": "Выбрать",
    "Create": "Создать",
    "Clear": "Очистить",
    "Manual Actions": "Ручные действия",
    "Open dependencies folder": "Открыть папку зависимостей",
    "Re-check deps": "Проверить зависимости",
    "Clear logs": "Очистить логи",
    "Logs (compact)": "Логи (компактно)",
    "Save Logs": "Сохранить логи",
    "Copy Logs": "Копировать логи",
    "Open log folder": "Открыть папку логов",
    "Tip: For Cordova, upload a ZIP with config.xml at root. For Android Studio, select project folder with gradlew.": 
        "Подсказка: Для Cordova загрузите ZIP с config.xml в корне. Для Android Studio выберите папку с gradlew.",
    "Ready": "Готово к загрузке проекта",
    "Language": "Язык",
    "Delete all project folders": "Удалить все папки проектов",
    "Cordova": "Cordova",
    "Android Studio": "Android Studio",
    "Debug APK": "Отладочный APK",
    "Unsigned Release APK": "Неподписанный релиз APK",
    "Unsigned AAB": "Неподписанный AAB",
    "Signed Debug APK": "Подписанный отладочный APK",
    "Signed Release APK": "Подписанный релиз APK",
    "Signed AAB": "Подписанный AAB",
    "Application started": "Приложение запущено",
    "Checking dependencies...": "Проверяю зависимости...",
    "Missing: {name} ({path})": "Не найдено: {name} ({path})",
    "Found: {name} ({path})": "Найдено: {name} ({path})",
    "Will install: {list}": "Установлю: {list}",
    "Installing dependency: {name}": "Устанавливаю: {name}",
    "Downloading {description} from {url}": "Скачиваю {description} из {url}",
    "Downloaded {description} → {path}": "Скачано {description} → {path}",
    "Extracting {description} to {target}...": "Распаковка {description} в {target}...",
    "{description} installed to {target}": "{description} установлено в {target}",
    "Flattening inner directory {inner} → {dir}": "Выравниваю вложенную папку {inner} → {dir}",
    "Installed Node.js: {version}": "Node.js установлен: {version}",
    "Installed JDK: {version}": "JDK установлен: {version}",
    "Android SDK command-line tools installed to {path}": "Android SDK установлен в {path}",
    "Created license file: {fname}": "Создан файл лицензии: {fname}",
    "License file exists: {fname}": "Файл лицензии уже есть: {fname}",
    "Accepting Android SDK licenses (writing license files + interactive sdkmanager)...": "Принимаю лицензии Android SDK (пишу файлы + запускаю sdkmanager)...",
    "sdkmanager accepted licenses (interactive)": "sdkmanager принял лицензии (интерактивно)",
    "Installing Android SDK components (build-tools, platforms, platform-tools)...": "Установка компонентов Android SDK (build-tools, platforms, platform-tools)...",
    "All dependencies installed and environment configured": "Все зависимости установлены и окружение настроено",
    "Loading Cordova ZIP: {zip}": "Загружаю Cordova ZIP: {zip}",
    "Cordova project loaded and validated (config.xml found)": "Cordova проект загружен и валиден (config.xml найден)",
    "Build started: {mode} for {ptype}": "Запущена сборку: {mode} для {ptype}",
    "Using Cordova command: {cmd}": "Используется Cordova: {cmd}",
    "Adding Android platform to Cordova (if missing)...": "Добавляю платформу Android в Cordova (если нужно)...",
    "Running Cordova build: {cmd}": "Запускаю Cordova build: {cmd}",
    "Found build artifacts: {paths}": "Найдено артефактов: {paths}",
    "Artifact ready: {path} (size {size})": "Готов артефакт: {path} (размер {size})",
    "Signing APK: {path}": "Подписываю APK: {path}",
    "APK signed: {path}": "APK подписан: {path}",
    "Signing AAB: {path}": "Подписываю AAB: {path}",
    "AAB signed with jarsigner: {path}": "AAB подписан jarsigner: {path}",
    "Command finished successfully (code {rc})": "Команда выполнена успешно (код {rc})",
    "Command finished with code {rc}": "Команда завершилась с кодом {rc}",
    "Error: {err}": "Ошибка: {err}",
    "Warning: {warn}": "Предупреждение: {warn}",
    "Keystore selected: {path}": "Keystore выбран: {path}",
    "Keystore created: {path}": "Keystore создан: {path}",
    "Keystore cleared": "Keystore очищен",
    "Logs saved: {path}": "Логи сохранены: {path}",
    "Language changed to {language}": "Язык переключен на {language}",
    "English": "English",
    "Russian": "Русский",
    "Installing Cordova CLI locally": "Устанавливаю Cordova CLI локально",
    "Cordova CLI installed: {version}": "Cordova CLI установлен: {version}",
    "Create a new keystore": "Создать новый keystore",
    "First and Last Name": "Имя и Фамилия",
    "Organizational Unit": "Подразделение организации",
    "Organization": "Организация",
    "City or Locality": "Город или Местность",
    "State or Province": "Штат или Провинция",
    "Country Code (XX)": "Код страны (XX)",
    "Alias": "Псевдоним",
    "Validity (years)": "Срок действия (лет)",
    "Keystore Password": "Пароль keystore",
    "Confirm Password": "Подтвердите пароль",
    "Key Password (optional, if different)": "Пароль ключа (опционально, если отличается)",
    "Cancel": "Отмена",
    "Help": "Помощь",
    "Passwords do not match": "Пароли не совпадают",
    "Fill all required fields": "Заполните все обязательные поля",
    "Keystore creation failed": "Создание keystore провалено",
    "No keystore configured for signed build": "Keystore не настроен для подписанной сборки",
    "Signing": "Подпись",
    "Keystore": "Хранилище ключей",
    "Download Info": "Информация о загрузке",
    "Speed: {speed}": "Скорость: {speed}",
    "ETA: {eta}": "Осталось: {eta}",
    "Speed: --": "Скорость: --",
    "ETA: --": "Осталось: --",
    "Removing dependencies...": "Удаляю зависимости...",
    "Starting dependency reinstallation...": "Начинаю переустановку зависимостей...",
    "Dependencies folder removed": "Папка зависимостей удалена",
                "Starting dependency check after removal...": "Начинаю проверку зависимостей после удаления...",
            "Error removing dependencies folder: {err}": "Ошибка удаления папки зависимостей: {err}",
            "Error during reinstall: {err}": "Ошибка во время переустановки: {err}",
    "Confirm Delete": "Подтвердить удаление",
    "This will delete all project folders. Continue?": "Это удалит все папки проектов. Продолжить?",
    "Key alias": "Псевдоним ключа",
    "Show passwords": "Показать пароли",
    "Key password (optional)": "Пароль ключа (опционально)",
    "Confirm": "Подтвердить",
    "Validity must be a number": "Срок действия должен быть числом",
    "Checking dependencies...": "Проверка зависимостей...",
    "Installing {dep}...": "Установка {dep}...",
    "Downloading {description}...": "Скачивание {description}...",
    "Downloading {description}... {percent}%": "Скачивание {description}... {percent}%",
    "Download completed": "Скачивание завершено",
    "Extracting {description}... {percent}%": "Распаковка {description}... {percent}%",
    "{description} installed": "{description} установлено",
    "Accepting SDK licenses...": "Принятие лицензий SDK...",
    "Licenses accepted": "Лицензии приняты",
    "Installing component: {comp}...": "Установка компонента: {comp}...",
    "Component {comp} installed": "Компонент {comp} установлен",
    "Loading ZIP archive...": "Загрузка ZIP-архива...",
    "Extracting ZIP archive... {percent}%": "Распаковка ZIP-архива... {percent}%",
    "Preparing project...": "Подготовка проекта...",
    "Project ready for build": "Проект готов к сборке",
    "Project loading error": "Ошибка загрузки проекта",
    "Starting build...": "Начало сборки...",
    "Starting Cordova build...": "Начало сборки Cordova...",
    "Adding Android platform...": "Добавление платформы Android...",
    "Android platform added": "Платформа Android добавлена",
    "Android platform already added": "Платформа Android уже добавлена",
    "Applying patches...": "Применение патчей...",
    "Build: {mode_internal}...": "Сборка: {mode_internal}...",
    "Build completed": "Сборка выполнена",
    "Artifacts found": "Артефакты найдены",
    "Signing completed": "Подпись завершена",
    "Build completed successfully": "Сборка завершена успешно",
    "Starting Android Studio build...": "Начало сборки Android Studio...",
    "Signing APK: {basename}...": "Подпись APK: {basename}...",
    "Signing AAB: {basename}...": "Подпись AAB: {basename}...",
    "Country code must be 2 letters": "Код страны должен состоять из 2 букв",
    "Validity must be positive": "Срок действия должен быть положительным",
    # Добавляем недостающие переводы
    "Error": "Ошибка",
    "Warning": "Предупреждение",
    "Dependencies are still being installed. Wait or re-run after installation.": "Зависимости все еще устанавливаются. Подождите или перезапустите после установки.",
    "No project loaded": "Проект не загружен",
    "Android Studio project loaded and validated (gradlew found)": "Проект Android Studio загружен и валиден (gradlew найден)",
    "gradlew not found in folder": "gradlew не найден в папке",
    "config.xml not found in ZIP": "config.xml не найден в ZIP",
    "npm not found in embedded Node — downloading npm package...": "npm не найден во встроенном Node — скачиваю пакет npm...",
    "Bootstrapped npm to {cli}": "npm загружен в {cli}",
    "Failed to bootstrap npm: {e}": "Не удалось загрузить npm: {e}",
    "npm-cli.js not found even after bootstrap": "npm-cli.js не найден даже после загрузки",
    "node.exe not found; cannot install Cordova": "node.exe не найден; невозможно установить Cordova",
    "Cordova installation failed; binary not found": "Установка Cordova провалена; бинарный файл не найден",
    "Cordova installation failed with code {rc}": "Установка Cordova провалена с кодом {rc}",
    "Cordova CLI not found in dependencies": "Cordova CLI не найден в зависимостях",
    "Cordova platform add failed with code {rc}": "Добавление платформы Cordova провалено с кодом {rc}",
    "Android platform already exists": "Платформа Android уже существует",
    "Added import groovy.xml.XmlParser to cordova.gradle": "Добавлен импорт groovy.xml.XmlParser в cordova.gradle",
    "cordova.gradle already patched": "cordova.gradle уже исправлен",
    "cordova.gradle not found, skipping patch": "cordova.gradle не найден, пропускаю исправление",
    "Cordova build failed with code {rc}": "Сборка Cordova провалена с кодом {rc}",
    "Gradle build failed with code {rc}": "Сборка Gradle провалена с кодом {rc}",
    "Keystore not configured for signed build": "Keystore не настроен для подписанной сборки",
    "zipalign not found": "zipalign не найден",
    "zipalign failed; continuing with original apk": "zipalign провален; продолжаю с оригинальным apk",
    "apksigner not found": "apksigner не найден",
    "apksigner returned {rc}": "apksigner вернул {rc}",
    "jarsigner not found": "jarsigner не найден",
    "jarsigner returned {rc}": "jarsigner вернул {rc}",
    "Command timeout": "Команда превысила время ожидания",
    "Executing: {cmd}": "Выполняется: {cmd}",
    "Environment variables configured:": "Переменные окружения настроены:",
    "JAVA_HOME: {path}": "JAVA_HOME: {path}",
    "ANDROID_HOME: {path}": "ANDROID_HOME: {path}",
    "GRADLE_HOME: {path}": "GRADLE_HOME: {path}",
    "PATH (prefix): {path}": "PATH (префикс): {path}",
    "Environment setup complete": "Настройка окружения завершена",
    "sdkmanager not found, skipping interactive license acceptance": "sdkmanager не найден, пропускаю интерактивное принятие лицензий",
    "sdkmanager returned {rc}": "sdkmanager вернул {rc}",
    "sdkmanager not found": "sdkmanager не найден",
    "Installing Android SDK component: {name}": "Установка компонента Android SDK: {name}",
    "{comp} install returned {rc}": "Установка {comp} вернула {rc}",
    "No project folders to delete": "Нет папок проектов для удаления",
    "Deleted all project folders: {path}": "Удалены все папки проектов: {path}",
    "Opening folder: {folder}": "Открываю папку: {folder}",
    "Failed to create log file: {e}": "Не удалось создать файл лога: {e}",
    "pyperclip not installed; cannot copy.": "pyperclip не установлен; невозможно копировать.",
    "Saved logs to: {target}": "Логи сохранены в: {target}",
    "Error updating UI texts: {err}": "Ошибка обновления текстов интерфейса: {err}",
    "Keystore selection incomplete": "Выбор keystore не завершен",
    "Enter keystore password:": "Введите пароль keystore:",
    "Enter key alias:": "Введите псевдоним ключа:",
    "Enter key password (if same as store, leave blank):": "Введите пароль ключа (если такой же как у хранилища, оставьте пустым):",
    "Select Keystore": "Выбрать Keystore",
    "Keystore password": "Пароль keystore",
    "Key alias": "Псевдоним ключа",
    "Key password": "Пароль ключа",
    "Project loaded": "Проект загружен",
    "Support Developer": "Поддержать разработчика",
    "Failed to open link: {error}": "Не удалось открыть ссылку: {error}",
    "HTML5 project loaded and validated (index.html found)": "Проект HTML5 загружен и валиден (найден index.html)",
    "gradlew or index.html not found in folder": "В папке не найден gradlew или index.html",
    "Tip: For Cordova, upload a ZIP with config.xml at root. For Android Studio, select project folder with gradlew. For HTML5, select a folder with index.html.": "Подсказка: Для Cordova загрузите ZIP с config.xml в корне. Для Android Studio выберите папку с gradlew. Для HTML5 выберите папку с index.html.",
    "Info": "Информация",
    "HTML5 projects don't require Android build. Use Cordova or Android Studio if you need APK/AAB.": "HTML5 проекты не требуют Android-сборки. Используйте Cordova или Android Studio, если нужен APK/AAB.",
    # HTML5 settings dialog
    "Configure HTML5": "Настроить HTML5",
    "Edit Config": "Редактировать конфиг",
    "HTML5 App Settings": "Настройки HTML5 приложения",
    "Configure HTML5 App": "Настройка HTML5 приложения",
    "App Icon": "Иконка приложения",
    "Upload Icon": "Загрузить иконку",
    "Splash Icon": "Иконка заставки",
    "Upload Splash": "Загрузить заставку",
    "General": "Общие",
    "App ID (e.g., com.app.id)": "ID приложения (например, com.app.id)",
    "App Name": "Название приложения",
    "Description": "Описание",
    "Version (x.y.z)": "Версия (x.y.z)",
    "Android version code": "Код версии Android",
    "Author": "Автор",
    "Email": "Email",
    "Website": "Сайт",
    "Android Versions": "Версии Android",
    "Min. version": "Мин. версия",
    "Target version: Android 14 (API level 34)": "Целевая версия: Android 14 (API уровень 34)",
    "Properties": "Свойства",
    "URL whitelist": "Белый список URL",
    "Hide status bar": "Скрыть статус-бар",
    "Require Vibrate permission": "Требовать разрешение на вибрацию",
    "Require Camera permission": "Требовать разрешение на камеру",
    "Require Microphone permission": "Требовать разрешение на микрофон",
    "Orientation": "Ориентация",
    "Portrait": "Портретная",
    "Landscape": "Альбомная",
    "Splash Screen": "Заставка",
    "Background color": "Цвет фона",
    "Pick": "Выбрать",
    "Select icon image": "Выберите изображение иконки",
    "Select splash image": "Выберите изображение заставки"
}
def translate(template, lang, **kwargs):
    if lang == 'ru' and template in TRANSLATIONS:
        try:
            return TRANSLATIONS[template].format(**kwargs)
        except Exception:
            return TRANSLATIONS[template]
    try:
        return template.format(**kwargs) if kwargs else template
    except Exception:
        return template
# ------------------------
# Logger
# ------------------------
class Logger:
    LEVELS = {
        "DEBUG": "🔍",
        "INFO": "ℹ️",
        "WARNING": "⚠️",
        "ERROR": "❌",
        "SUCCESS": "✅"
    }
    def __init__(self, text_widget, get_lang_callable):
        self.text_widget = text_widget
        self.get_lang = get_lang_callable
        self._ensure_log_file()
        self._setup_tags()
    def _ensure_log_file(self):
        safe_makedirs(os.path.join(os.getcwd(), "logs"))
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.logfile = os.path.join(os.getcwd(), "logs", f"app_{ts}.log")
        try:
            with open(self.logfile, "w", encoding="utf-8") as f:
                f.write(f"=== LOG STARTED AT {datetime.now().isoformat()} ===\n")
        except Exception as e:
            print(f"Failed to create log file: {e}")
    def _setup_tags(self):
        try:
            self.text_widget.tag_config("debug", foreground="gray")
            self.text_widget.tag_config("info", foreground="white")
            self.text_widget.tag_config("warning", foreground="orange")
            self.text_widget.tag_config("error", foreground="red")
            self.text_widget.tag_config("success", foreground="light green")
        except Exception:
            pass
    def _write_file(self, line):
        try:
            with open(self.logfile, "a", encoding="utf-8") as f:
                f.write(line)
        except Exception:
            pass
    def raw(self, line):
        if line is None:
            return
        if isinstance(line, bytes):
            try:
                line = line.decode("utf-8", errors="replace")
            except Exception:
                line = str(line)
        if not line.endswith("\n"):
            line = line + "\n"
        ts = datetime.now().strftime("%H:%M:%S")
        out = f"[{ts}] {line}"
        try:
            self.text_widget.configure(state="normal")
            self.text_widget.insert("end", out, "debug")
            self.text_widget.configure(state="disabled")
            self.text_widget.see("end")
        except Exception:
            print(out, end="")
        self._write_file(out)
    def log(self, template, level="INFO", **kwargs):
        level = level.upper()
        prefix = self.LEVELS.get(level, "•")
        ts = datetime.now().strftime("%H:%M:%S")
        lang = self.get_lang() or 'en'
        try:
            eng = template.format(**kwargs) if kwargs else template
        except Exception:
            eng = template
        loc = translate(template, lang, **kwargs)
        ui_line = f"[{ts}] {prefix} {loc}\n"
        file_line = f"[{ts}] {prefix} {eng} -> {loc}\n"
        try:
            self.text_widget.configure(state="normal")
            tag = level.lower() if level.lower() in ("debug", "info", "warning", "error", "success") else None
            if tag:
                self.text_widget.insert("end", ui_line, tag)
            else:
                self.text_widget.insert("end", ui_line)
            self.text_widget.configure(state="disabled")
            self.text_widget.see("end")
        except Exception:
            print(ui_line, end="")
        self._write_file(file_line)
    def export(self, main_app=None):
        try:
            if main_app:
                # Use native dialog if main app is provided
                target = filedialog.asksaveasfilename(
                    title="Save Logs",
                    defaultextension=".log",
                    filetypes=[("Log files", "*.log"), ("All files", "*.*")]
                )
            else:
                # Fallback to native dialog
                target = filedialog.asksaveasfilename(
                    title="Save Logs",
                    defaultextension=".log",
                    filetypes=[("Log files", "*.log"), ("All files", "*.*")]
                )
            if not target:
                return
            shutil.copyfile(self.logfile, target)
            self.log("Logs saved: {path}", "SUCCESS", path=target)
            if main_app:
                main_app._show_message("Logs", f"Saved logs to: {target}", "info")
            else:
                # Create native message box
                messagebox.showinfo("Logs", f"Saved logs to: {target}")
        except Exception as e:
            self.log("Error: {err}", "ERROR", err=str(e))
    def copy(self):
        try:
            content = self.text_widget.get("1.0", "end")
            pyperclip.copy(content)
            self.log("Copy Logs", "SUCCESS")
        except Exception as e:
            self.log("Error: {err}", "ERROR", err=str(e))
    def clear_ui(self):
        try:
            self.text_widget.configure(state="normal")
            self.text_widget.delete("1.0", "end")
            self.text_widget.configure(state="disabled")
            self.log("Ready", "INFO")
        except Exception:
            pass
# ------------------------
# Custom Dialog Classes
# ------------------------
class CustomMessageBox(ctk.CTkToplevel):
    def __init__(self, parent, title, message, message_type="info", buttons=None, default_button=None):
        super().__init__(parent)
        self.title(title)
        self.result = None
        
        # Set default buttons if none provided
        if buttons is None:
            buttons = ["OK"]
        if default_button is None:
            default_button = buttons[0]
            
        # Calculate height based on message length and number of buttons
        message_lines = message.count('\n') + 1
        button_height = 40 if len(buttons) > 1 else 30
        total_height = max(200, 120 + message_lines * 20 + button_height)
        
        self.geometry(f"400x{total_height}")
        self.resizable(False, False)
        self.transient(parent)
        self.grab_set()
        
        # Center the dialog
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (400 // 2)
        y = (self.winfo_screenheight() // 2) - (total_height // 2)
        self.geometry(f"400x{total_height}+{x}+{y}")
        
        # Configure grid
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)
        
        # Icon and title
        icon_text = "ℹ️" if message_type == "info" else "⚠️" if message_type == "warning" else "❌"
        icon_label = ctk.CTkLabel(self, text=icon_text, font=("Arial", 24))
        icon_label.grid(row=0, column=0, pady=(20, 10))
        
        # Message
        message_label = ctk.CTkLabel(self, text=message, wraplength=350, font=("Arial", 12))
        message_label.grid(row=1, column=0, padx=20, pady=10)
        
        # Buttons frame
        button_frame = ctk.CTkFrame(self)
        button_frame.grid(row=2, column=0, pady=(0, 20))
        
        # Create buttons
        for i, button_text in enumerate(buttons):
            is_default = button_text == default_button
            button = ctk.CTkButton(
                button_frame, 
                text=button_text, 
                command=lambda text=button_text: self._button_clicked(text),
                width=80 if len(buttons) > 1 else 100,
                fg_color="#e74c3c" if button_text == "Yes" else None  # Red for Yes button
            )
            button.pack(side="left" if len(buttons) > 1 else "top", padx=5, pady=5)
            
            # Make default button focused
            if is_default:
                button.focus_set()
        
        # Bind Enter key to default button
        self.bind("<Return>", lambda e: self._button_clicked(default_button))
        self.focus_set()
        
        # Set icon AFTER all widgets are created to prevent interference
        set_window_icon(self)
        
    def _button_clicked(self, button_text):
        self.result = button_text
        self.destroy()
# ------------------------
# Main Application
# ------------------------
class MainApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Saturn Builder")
        self.geometry("1160x760")
        self.minsize(980, 640)
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("blue")
        # Set icon AFTER customtkinter configuration to prevent override
        set_window_icon(self)
        # Directories
        # Resolve base directory relative to the app/script location (not the current working directory)
        try:
            if getattr(sys, 'frozen', False):
                # Running as a bundled executable
                _base = os.path.dirname(sys.executable)
            else:
                # Running as a script
                _base = os.path.dirname(os.path.abspath(__file__))
        except Exception:
            # Fallback to current working directory
            _base = os.path.abspath(os.getcwd())
        self.BASE = _base
        self.DEP_DIR = os.path.join(self.BASE, "dependencies")
        self.PROJ_DIR = os.path.join(self.BASE, "projects")
        self.LOGS_DIR = os.path.join(self.BASE, "logs")
        safe_makedirs(self.DEP_DIR)
        safe_makedirs(self.PROJ_DIR)
        safe_makedirs(self.LOGS_DIR)
        # State
        self.lang = 'en'
        self.project_types_internal = ["Cordova", "Android Studio", "HTML5"]
        self.build_types_internal = [
            "Debug APK",
            "Unsigned Release APK",
            "Unsigned AAB",
            "Signed Debug APK",
            "Signed Release APK",
            "Signed AAB"
        ]
        self.project_display_var = tk.StringVar()
        self.build_display_var = tk.StringVar()
        self.project_internal_var = tk.StringVar(value=self.project_types_internal[0])
        self.build_internal_var = tk.StringVar(value=self.build_types_internal[0])
        self.keystore_info = {}
        self.project_loaded = False
        self.project_path = None
        self.dependencies_installed = False
        self._cached_env = None
        self.keystore_dialog = None
        self.welcome_shown = False
        # Веса для прогресс-бара (общий прогресс установки зависимостей)
        self.dependency_weights = {
            "Node.js": 20,
            "JDK": 20,
            "Android SDK command-line tools": 30,
            "Gradle": 15,
            "Cordova CLI": 15
        }
        # Добавленные переменные для улучшенного прогресс-бара
        self.current_progress = 0  # Текущее значение прогресса
        self.target_progress = 0   # Целевое значение прогресса для плавного перехода
        self.progress_animation_id = None # ID анимации для after_cancel
        self.current_task = tk.StringVar(value=self._tr("Ready"))  # Текущая задача
        # Keystore vars
        self.ks_path_var = tk.StringVar(value=self._tr("Not selected"))
        self.alias_var = tk.StringVar()
        self.ks_pass_var = tk.StringVar()
        self.key_pass_var = tk.StringVar()
        self.show_pass_var = tk.BooleanVar(value=False)
        self.html5_pending_config = False
        # UI creation
        self._build_ui()
        self.logger = Logger(self.log_widget, self._get_lang)
        self.logger.log("Application started", "INFO")
        
        # Проверяем, нужно ли показать приветственное окно
        self._check_first_run()
        
        self.protocol("WM_DELETE_WINDOW", self._on_closing)
        # Trace for keystore info update
        self.ks_path_var.trace_add("write", self._update_keystore_info)
        self.alias_var.trace_add("write", self._update_keystore_info)
        self.ks_pass_var.trace_add("write", self._update_keystore_info)
        self.key_pass_var.trace_add("write", self._update_keystore_info)
        # Trace for build type to toggle signing section
        self.build_internal_var.trace_add("write", self._toggle_signing_section)
        self._toggle_signing_section()
    def _get_lang(self):
        return self.lang
    def _tr(self, text, **kwargs):
        return translate(text, self.lang, **kwargs)
    def _localize_display(self, key):
        return translate(key, self.lang)
    
    def _show_message(self, title, message, message_type="info"):
        """Show native message box"""
        if message_type == "error":
            messagebox.showerror(title, message)
        elif message_type == "warning":
            messagebox.showwarning(title, message)
        else:
            messagebox.showinfo(title, message)
    
    def _show_support_dialog(self):
        """Показывает окно поддержки неблокирующим образом в координатах курсора"""
        try:
            import tkinter as tk
            
            # Получаем текущий язык
            lang = self._get_lang()
            
            # Создаем окно поддержки
            support_dialog = CoffeeSupportDialog(self, lang)
            
            # Получаем координаты курсора мыши
            x = self.winfo_pointerx()
            y = self.winfo_pointery()
            
            # Получаем размеры окна
            window_width = 600
            window_height = 600
            
            # Вычисляем позицию так, чтобы окно было центрировано относительно курсора
            pos_x = x - (window_width // 2)
            pos_y = y - (window_height // 2)
            
            # Устанавливаем позицию окна
            support_dialog.geometry(f"{window_width}x{window_height}+{pos_x}+{pos_y}")
            
            # Делаем окно поверх всех остальных окон
            support_dialog.lift()  # Поднимаем окно наверх
            support_dialog.focus_force()  # Принудительно фокусируемся на окне
            
            # Делаем окно неблокирующим
            support_dialog.grab_release()
            support_dialog.transient(self)
            
            # Дополнительно поднимаем окно наверх через небольшую задержку
            support_dialog.after(100, lambda: support_dialog.lift())
            
        except Exception as e:
            self.logger.log("Failed to show support dialog: {error}", "WARNING", error=str(e))
    def _open_html5_config_dialog(self):
        try:
            # Если в проекте уже есть config.xml, переключаемся на Cordova и не открываем окно HTML5
            try:
                proj = getattr(self, 'project_path', None)
                if proj:
                    cfg_xml = os.path.join(proj, 'config.xml')
                    if os.path.exists(cfg_xml):
                        self.logger.log("Detected Cordova config.xml in HTML5 flow — switching to Cordova", "INFO")
                        self.project_internal_var.set("Cordova")
                        self.project_display_var.set(self._localize_display("Cordova"))
                        self._rebuild_optionmenus()
                        self.btn_build.configure(state="normal")
                        # Прячем кнопки HTML5 конфигурации
                        try:
                            self.btn_html5_config.pack_forget()
                            self.btn_html5_config_top.pack_forget()
                        except Exception:
                            pass
                        return
            except Exception:
                pass
            Html5ConfigDialog(self, self._apply_html5_config)
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
    def _safe_min_api(self, v):
        return str(v or "24")
    def _apply_html5_config(self, cfg, icon_img):
        try:
            # target project folder already in self.project_path (contains index.html)
            proj = self.project_path
            www = os.path.join(proj, "www")
            safe_makedirs(www)
            # Move all existing files into www except www itself
            for item in os.listdir(proj):
                if item == "www":
                    continue
                src = os.path.join(proj, item)
                dst = os.path.join(www, item)
                try:
                    if os.path.isdir(src):
                        shutil.move(src, dst)
                    else:
                        shutil.move(src, os.path.join(www, item))
                except Exception:
                    pass
            # Save icon into www/res and add platform-specific icons for Cordova
            icons_dir = os.path.join(www, "res")
            safe_makedirs(icons_dir)
            icon_rel = None
            try:
                if icon_img and Image:
                    variants = {
                        "mipmap-mdpi": 48,
                        "mipmap-hdpi": 72,
                        "mipmap-xhdpi": 96,
                        "mipmap-xxhdpi": 144,
                        "mipmap-xxxhdpi": 192
                    }
                    for folder, size in variants.items():
                        d = os.path.join(icons_dir, folder)
                        safe_makedirs(d)
                        p = os.path.join(d, "ic_launcher.png")
                        icon_img.resize((size,size), Image.Resampling.LANCZOS).save(p, format="PNG")
                    # основной 128
                    p128 = os.path.join(icons_dir, "icon-128.png")
                    icon_img.resize((128,128), Image.Resampling.LANCZOS).save(p128, format="PNG")
                    icon_rel = os.path.relpath(p128, proj).replace('\\','/')
            except Exception as _e:
                self.logger.log("Warning: {warn}", "WARNING", warn=f"Icon generation failed: {_e}")
            # Create config.json (app metadata)
            config_json = {
                "id": cfg["id"],
                "version": cfg["version"],
                "versionCode": cfg["versionCode"],
                "name": cfg["name"],
                "description": cfg["description"],
                "whitelist": cfg["whitelist"].split(),
                "author": cfg["author"],
                "email": cfg["email"],
                "website": cfg["website"],
                "orientation": cfg["orientation"],
                "fullscreen": cfg["hideStatus"],
                "permissionTypes": [p for p,flag in (("camera",cfg["permCamera"]),("microphone",cfg["permMic"])) if flag],
                "icons": ([{"src": icon_rel or "www/icons/icon-128.png", "width":128, "height":128, "density":"xxhdpi"}] if icon_rel else []),
                "android": {"min": cfg["minApi"], "target": cfg["targetApi"], "engine": "12.0.0"}
            }
            with open(os.path.join(proj, "config.json"), "w", encoding="utf-8") as f:
                import json
                json.dump(config_json, f, ensure_ascii=False, indent=2)
            # Create simplistic config.xml for Cordova
            # Генерируем config.xml
            splash_prefs = ""
            config_xml = f"""
<?xml version='1.0' encoding='utf-8'?>
<widget id="{cfg['id']}" version="{cfg['version']}" xmlns="http://www.w3.org/ns/widgets" xmlns:cdv="http://cordova.apache.org/ns/1.0">
  <name>{cfg['name']}</name>
  <description>{cfg['description']}</description>
  <author email="{cfg['email']}" href="{cfg['website']}">{cfg['author']}</author>
  <preference name="Orientation" value="{cfg['orientation']}" />
  <preference name="Fullscreen" value="{'true' if cfg['hideStatus'] else 'false'}" />
  {splash_prefs}
  <platform name="android">
    <preference name="android-minSdkVersion" value="{cfg['minApi']}" />
    <preference name="android-targetSdkVersion" value="{cfg['targetApi']}" />
    <icon density="mdpi" src="www/res/mipmap-mdpi/ic_launcher.png" />
    <icon density="hdpi" src="www/res/mipmap-hdpi/ic_launcher.png" />
    <icon density="xhdpi" src="www/res/mipmap-xhdpi/ic_launcher.png" />
    <icon density="xxhdpi" src="www/res/mipmap-xxhdpi/ic_launcher.png" />
    <icon density="xxxhdpi" src="www/res/mipmap-xxxhdpi/ic_launcher.png" />
  </platform>
  {''.join([f'<allow-navigation href="{u}" />' for u in cfg['whitelist'].split()])}
</widget>
""".strip()
            with open(os.path.join(proj, "config.xml"), "w", encoding="utf-8") as f:
                f.write(config_xml)
            # Create package.json minimal
            package_json = {
                "name": cfg["name"].lower().replace(" ", "-"),
                "version": cfg["version"],
                "private": True,
                "dependencies": {}
            }
            with open(os.path.join(proj, "package.json"), "w", encoding="utf-8") as f:
                import json
                json.dump(package_json, f, ensure_ascii=False, indent=2)
            # Apply splash icon configuration
            self._ensure_splash_icon_config(proj, icon_img, None, cfg)
            
            # Keep UI type as HTML5 but enable Cordova-based build under the hood
            # Сохраняем выбранный тип проекта как HTML5, но собирать будем через Cordova
            self.project_internal_var.set("HTML5")
            self.project_display_var.set(self._localize_display("HTML5"))
            self._rebuild_optionmenus()
            self.btn_build.configure(state="normal")
            self.html5_pending_config = False
            # Оставляем кнопку редактирования конфига доступной
            self.logger.log("HTML5 config applied; project packaged for Cordova build (UI stays HTML5)", "SUCCESS")
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
    
        
    def _check_first_run(self):
        """Проверяет, нужно ли показать приветственное окно при первом запуске"""
        welcome_flag_file = os.path.join(self.BASE, ".welcome_shown")
        
        # Проверяем, есть ли уже установленные зависимости
        node_dir = os.path.join(self.DEP_DIR, "node")
        jdk_dir = os.path.join(self.DEP_DIR, "jdk")
        sdk_tools_dir = os.path.join(self.DEP_DIR, "android-sdk", "cmdline-tools", "latest")
        gradle_dir = os.path.join(self.DEP_DIR, "gradle")
        cordova_dir = os.path.join(self.DEP_DIR, "node", "node_modules", "cordova")
        
        node_exe = os.path.join(node_dir, "node.exe" if platform.system() == "Windows" else "bin/node")
        java_exe = os.path.join(jdk_dir, "bin", "java.exe" if platform.system() == "Windows" else "bin/java")
        sdkmanager_exe = os.path.join(sdk_tools_dir, "bin", "sdkmanager.bat" if platform.system() == "Windows" else "sdkmanager")
        gradle_exe = os.path.join(gradle_dir, "bin", "gradle.bat" if platform.system() == "Windows" else "bin/gradle")
        cordova_exe = os.path.join(cordova_dir, "bin", "cordova")
        
        dependencies_exist = all([
            os.path.exists(node_exe),
            os.path.exists(java_exe),
            os.path.exists(sdkmanager_exe),
            os.path.exists(gradle_exe),
            os.path.exists(cordova_exe)
        ])
        
        # Если зависимости уже установлены, не показываем приветственное окно
        if dependencies_exist:
            self.dependencies_installed = True
            self._setup_environment()
            self.logger.log("All dependencies already installed", "SUCCESS")
            self._set_progress(100, self._tr("Ready"))
            self.after(0, lambda: self.btn_load.configure(state="normal"))
            return
            
        # Если приветственное окно уже показывалось, проверяем зависимости только если они не установлены
        if os.path.exists(welcome_flag_file):
            if not dependencies_exist:
                threading.Thread(target=self.check_dependencies, daemon=True).start()
            else:
                # Зависимости уже установлены, просто настраиваем окружение
                self.dependencies_installed = True
                self._setup_environment()
                self.logger.log("All dependencies already installed", "SUCCESS")
                self._set_progress(100, self._tr("Ready"))
                self.after(0, lambda: self.btn_load.configure(state="normal"))
            return
            
        # Показываем приветственное окно
        self.after(100, self._show_welcome_dialog)
        
    def _show_welcome_dialog(self):
        """Показывает приветственное окно"""
        if self.welcome_shown:
            return
            
        self.welcome_shown = True
        welcome_dialog = WelcomeDialog(self, self._on_welcome_choice)
        
    def _on_welcome_choice(self, choice):
        """Обрабатывает выбор пользователя в приветственном окне"""
        welcome_flag_file = os.path.join(self.BASE, ".welcome_shown")
        
        # Создаем файл-флаг, что приветственное окно было показано
        try:
            with open(welcome_flag_file, "w") as f:
                f.write("1")
        except Exception:
            pass
            
        if choice == "install":
            # Пользователь выбрал установку зависимостей
            self.logger.log("User chose to install dependencies", "INFO")
            threading.Thread(target=self.check_dependencies, daemon=True).start()
        else:
            # Пользователь пропустил установку
            self.logger.log("User chose to skip dependency installation", "INFO")
            self._set_progress(0, self._tr("Ready"))
            # Показываем информационное окно
            self.after(500, lambda: SkipDependenciesDialog(self))
    def _rebuild_optionmenus(self):
        proj_values = [self._localize_display(k) for k in self.project_types_internal]
        self._proj_display_to_internal = {self._localize_display(k): k for k in self.project_types_internal}
        try:
            self.opt_project.configure(values=proj_values)
            current_internal = self.project_internal_var.get()
            self.project_display_var.set(self._localize_display(current_internal))
        except Exception:
            pass
        build_values = [self._localize_display(k) for k in self.build_types_internal]
        self._build_display_to_internal = {self._localize_display(k): k for k in self.build_types_internal}
        try:
            self.opt_build.configure(values=build_values)
            current_internal_b = self.build_internal_var.get()
            self.build_display_var.set(self._localize_display(current_internal_b))
        except Exception:
            pass
    def _build_ui(self):
        pad = 12
        header = ctk.CTkFrame(self, corner_radius=12)
        header.pack(fill="x", padx=pad, pady=(pad, 6))
        self.lbl_project_type = ctk.CTkLabel(header, text=self._tr("Project type:"))
        self.lbl_project_type.pack(side="left", padx=(8, 6))
        self.opt_project = ctk.CTkOptionMenu(header, values=[], variable=self.project_display_var, width=160, command=self._on_project_display_change)
        self.opt_project.pack(side="left", padx=(0, 10))
        self.btn_load = ctk.CTkButton(header, text=f"📂 {self._tr('Load Project')}", width=220, command=self.load_project, state="disabled")
        self.btn_load.pack(side="left", padx=(0, 10))
        self.lbl_build = ctk.CTkLabel(header, text=self._tr("Build:"))
        self.lbl_build.pack(side="left", padx=(6, 6))
        self.opt_build = ctk.CTkOptionMenu(header, values=[], variable=self.build_display_var, width=320, command=self._on_build_display_change)
        self.opt_build.pack(side="left", padx=(0, 10))
        self.btn_build = ctk.CTkButton(header, text=self._tr("⚡ Build"), width=160, fg_color="#2ecc71", command=self.start_build, state="disabled")
        self.btn_build.pack(side="left", padx=(0, 10))
        # Кнопка редактирования конфига (для HTML5)
        self.btn_html5_config_top = ctk.CTkButton(header, text=self._tr("Edit Config"), width=160, fg_color="#2ecc71", command=self._open_html5_config_dialog)
        self.btn_html5_config_top.pack(side="left", padx=(3, 3))
        self.btn_html5_config_top.pack_forget()
        status_frame = ctk.CTkFrame(self, corner_radius=12)
        status_frame.pack(fill="x", padx=pad, pady=(6, 0))
        # Создаем метку для отображения текущей задачи
        self.task_label = ctk.CTkLabel(status_frame, textvariable=self.current_task, anchor="w", font=("Arial", 12))
        self.task_label.pack(fill="x", padx=10, pady=(5, 0))
        # Стилизация прогресс-бара
        style = ttk.Style()
        style.theme_use("clam")
        style.configure("Custom.Horizontal.TProgressbar",
            troughcolor="#2b2b2b",
            bordercolor="#1f1f1f",
            background="#2ecc71",
            lightcolor="#2ecc71",
            darkcolor="#27ae60",
            thickness=12,
            borderwidth=0,
            relief="flat")
        self.progress = ttk.Progressbar(status_frame, orient="horizontal", mode="determinate", style="Custom.Horizontal.TProgressbar")
        self.progress.pack(fill="x", padx=10, pady=(0, 5))
        self.progress["maximum"] = 100
        self._set_progress(0, self._tr("Ready"))
        # Метка для отображения глобального прогресса
        self.global_percent = ctk.CTkLabel(status_frame, text="0%", font=("Arial", 12, "bold"), anchor="e")
        self.global_percent.pack(fill="x", padx=10, pady=(0, 10))
        center = ctk.CTkFrame(self, corner_radius=12)
        center.pack(fill="both", expand=True, padx=pad, pady=(6, pad))
        left = ctk.CTkFrame(center, corner_radius=12)
        left.pack(side="left", fill="both", expand=True, padx=(10, 6), pady=10)
        proj_info = ctk.CTkFrame(left, corner_radius=12)
        proj_info.pack(fill="x", padx=10, pady=8)
        self.project_info_var = tk.StringVar(value=self._tr("No project loaded"))
        ctk.CTkLabel(proj_info, textvariable=self.project_info_var, wraplength=520).pack(padx=8, pady=8)
        self.ks_frame = ctk.CTkFrame(left, corner_radius=12)
        # pack will be managed by _toggle_signing_section
        self.lbl_ks = ctk.CTkLabel(self.ks_frame, text=self._tr("Signing"))
        self.lbl_ks.pack(anchor="w", padx=8, pady=(6, 0))
        ks_path_frame = ctk.CTkFrame(self.ks_frame)
        ks_path_frame.pack(fill="x", padx=8, pady=5)
        self.lbl_ks_path = ctk.CTkLabel(ks_path_frame, text=self._tr("Keystore"))
        self.lbl_ks_path.pack(side="left", padx=5)
        entry_ks_path = ctk.CTkEntry(ks_path_frame, state="readonly", textvariable=self.ks_path_var)
        entry_ks_path.pack(side="left", fill="x", expand=True, padx=5)
        self.btn_choose_ks = ctk.CTkButton(ks_path_frame, text=self._tr("Choose"), width=80, command=self._choose_keystore)
        self.btn_choose_ks.pack(side="left", padx=5)
        self.btn_create_ks = ctk.CTkButton(ks_path_frame, text=self._tr("Create"), width=80, command=self._create_keystore_dialog)
        self.btn_create_ks.pack(side="left", padx=5)
        self.lbl_alias = ctk.CTkLabel(self.ks_frame, text=self._tr("Key alias"))
        self.lbl_alias.pack(anchor="w", padx=8, pady=5)
        entry_alias = ctk.CTkEntry(self.ks_frame, textvariable=self.alias_var)
        entry_alias.pack(fill="x", padx=8, pady=5)
        self.checkbox_show = ctk.CTkCheckBox(self.ks_frame, text=self._tr("Show passwords"), variable=self.show_pass_var, command=self._toggle_show_pass)
        self.checkbox_show.pack(anchor="w", padx=8, pady=5)
        self.lbl_ks_pass = ctk.CTkLabel(self.ks_frame, text=self._tr("Keystore Password"))
        self.lbl_ks_pass.pack(anchor="w", padx=8, pady=5)
        self.entry_ks_pass = ctk.CTkEntry(self.ks_frame, textvariable=self.ks_pass_var, show="*")
        self.entry_ks_pass.pack(fill="x", padx=8, pady=5)
        self.lbl_key_pass = ctk.CTkLabel(self.ks_frame, text=self._tr("Key password (optional)"))
        self.lbl_key_pass.pack(anchor="w", padx=8, pady=5)
        self.entry_key_pass = ctk.CTkEntry(self.ks_frame, textvariable=self.key_pass_var, show="*")
        self.entry_key_pass.pack(fill="x", padx=8, pady=5)
        self.btn_clear_ks = ctk.CTkButton(self.ks_frame, text=self._tr("Clear"), width=100, command=self._clear_keystore)
        self.btn_clear_ks.pack(pady=10, padx=8)
        manual_frame = ctk.CTkFrame(left, corner_radius=12)
        manual_frame.pack(fill="x", padx=10, pady=8)
        man_header = ctk.CTkFrame(manual_frame, corner_radius=8)
        man_header.pack(fill="x", padx=8, pady=8)
        ctk.CTkLabel(man_header, text="⚙️", width=36).pack(side="left", padx=(4, 6))
        self.lbl_manual = ctk.CTkLabel(man_header, text=self._tr("Manual Actions"), font=ctk.CTkFont(size=16, weight="bold"))
        self.lbl_manual.pack(side="left", padx=(2, 12))
        
        # First row of controls
        man_controls_row1 = ctk.CTkFrame(manual_frame, corner_radius=8)
        man_controls_row1.pack(fill="x", padx=8, pady=(0, 6))
        self.btn_open_deps = ctk.CTkButton(man_controls_row1, text=self._tr("Open dependencies folder"), width=230, command=self._open_dependencies)
        self.btn_open_deps.pack(side="left", padx=6, pady=6)
        self.btn_recheck = ctk.CTkButton(man_controls_row1, text=self._tr("Re-check deps"), width=170, command=lambda: threading.Thread(target=self.check_dependencies, daemon=True).start())
        self.btn_recheck.pack(side="left", padx=6, pady=6)
        self.btn_clear_logs = ctk.CTkButton(man_controls_row1, text=self._tr("Clear logs"), width=150, command=lambda: self.logger.clear_ui())
        self.btn_clear_logs.pack(side="left", padx=6, pady=6)
        
        # Second row of controls
        man_controls_row2 = ctk.CTkFrame(manual_frame, corner_radius=8)
        man_controls_row2.pack(fill="x", padx=8, pady=(0, 8))
        self.btn_delete_projects = ctk.CTkButton(man_controls_row2, text=self._tr("Delete all project folders"), width=230, command=self._delete_project_folders, fg_color="#e74c3c")
        self.btn_delete_projects.pack(side="left", padx=6, pady=6)

        # Language section moved to second row, right side after reinstall button
        lang_frame = ctk.CTkFrame(man_controls_row2, corner_radius=6)
        lang_frame.pack(side="right", padx=6, pady=6)
        self.lang_label = ctk.CTkLabel(lang_frame, text=self._tr("Language"))
        self.lang_label.pack(side="left", padx=(8, 6))
        self.lang_btn_font = ctk.CTkFont(size=14, weight="bold")
        self.lang_btn = ctk.CTkButton(lang_frame, text="English", width=120, height=42, font=self.lang_btn_font, command=self._toggle_language)
        self.lang_btn.pack(side="left", padx=(0, 8))
        self._update_lang_button()
        right = ctk.CTkFrame(center, corner_radius=12)
        right.pack(side="left", fill="both", expand=True, padx=(6, 10), pady=10)
        
        # Download info section
        download_info_frame = ctk.CTkFrame(right, corner_radius=8)
        download_info_frame.pack(fill="x", padx=8, pady=(8, 6))
        ctk.CTkLabel(download_info_frame, text="📥", width=36).pack(side="left", padx=(4, 6))
        ctk.CTkLabel(download_info_frame, text=self._tr("Download Info"), font=ctk.CTkFont(size=14, weight="bold")).pack(side="left", padx=(2, 12))
        
        # Download speed and ETA labels
        self.download_speed_label = ctk.CTkLabel(right, text=self._tr("Speed: --"), font=("Arial", 10))
        self.download_speed_label.pack(anchor="w", padx=12, pady=(0, 2))
        self.download_eta_label = ctk.CTkLabel(right, text=self._tr("ETA: --"), font=("Arial", 10))
        self.download_eta_label.pack(anchor="w", padx=12, pady=(0, 8))
        
        self.lbl_logs = ctk.CTkLabel(right, text=self._tr("Logs (compact)"))
        self.lbl_logs.pack(anchor="w", padx=8, pady=(8, 0))
        self.log_widget = scrolledtext.ScrolledText(right, wrap="word", height=30, bg="#0b0b0b", fg="#e0e0e0", font=("Consolas", 10))
        self.log_widget.pack(fill="both", expand=True, padx=8, pady=8)
        self.log_widget.configure(state="disabled")
        log_btns = ctk.CTkFrame(right, corner_radius=8)
        log_btns.pack(fill="x", padx=8, pady=(0, 8))
        self.btn_save_logs = ctk.CTkButton(log_btns, text=self._tr("Save Logs"), width=140, command=lambda: self.logger.export(self))
        self.btn_save_logs.pack(side="left", padx=6)
        self.btn_copy_logs = ctk.CTkButton(log_btns, text=self._tr("Copy Logs"), width=140, command=lambda: self.logger.copy())
        self.btn_copy_logs.pack(side="left", padx=6)
        self.btn_open_logs = ctk.CTkButton(log_btns, text=self._tr("Open log folder"), width=160, command=self._open_logs_dir)
        self.btn_open_logs.pack(side="left", padx=6)
        # Кнопка настройки конфигурации для HTML5 проектов
        footer = ctk.CTkFrame(self, corner_radius=12)
        footer.pack(fill="x", padx=pad, pady=(0, pad))
        self.hint_var = tk.StringVar(value=self._tr("Tip: For Cordova, upload a ZIP with config.xml at root. For Android Studio, select project folder with gradlew. For HTML5, select a folder with index.html."))
        ctk.CTkLabel(footer, textvariable=self.hint_var).pack(anchor="w", padx=10, pady=8)
        self._rebuild_optionmenus()
        self.project_display_var.trace_add("write", self._on_project_display_var_changed)
        self.build_display_var.trace_add("write", self._on_build_display_var_changed)
    def _toggle_signing_section(self, *args):
        if self.build_internal_var.get().startswith("Signed"):
            self.ks_frame.pack(fill="x", padx=10, pady=8)
        else:
            self.ks_frame.pack_forget()
    def _on_project_display_change(self, *args):
        try:
            # Скрываем кнопку HTML5-конфига, если выбран не HTML5
            current = self.project_display_var.get()
            internal = self._proj_display_to_internal.get(current, self.project_types_internal[0])
            if internal == "HTML5":
                try:
                    self.btn_html5_config_top.pack(side="left", padx=(3, 3))
                except Exception:
                    pass
                try:
                    self.btn_html5_config.pack(anchor="w", padx=8, pady=(4, 8))
                except Exception:
                    pass
            else:
                try:
                    self.btn_html5_config_top.pack_forget()
                except Exception:
                    pass
                try:
                    self.btn_html5_config.pack_forget()
                except Exception:
                    pass
        except Exception:
            pass
    def _on_build_display_change(self, *args):
        pass
    def _on_project_display_var_changed(self, *args):
        val = self.project_display_var.get()
        internal = self._proj_display_to_internal.get(val, self.project_types_internal[0])
        self.project_internal_var.set(internal)
    def _on_build_display_var_changed(self, *args):
        val = self.build_display_var.get()
        internal = self._build_display_to_internal.get(val, self.build_types_internal[0])
        self.build_internal_var.set(internal)
    def _update_lang_button(self):
        if self.lang == 'en':
            self.lang_btn.configure(text="Русский")
        else:
            self.lang_btn.configure(text="English")
    def _toggle_language(self):
        self.lang = 'ru' if self.lang == 'en' else 'en'
        self._rebuild_optionmenus()
        self._refresh_ui_texts()
        self._update_lang_button()
        lang_name_local = self._tr("Russian") if self.lang == 'ru' else self._tr("English")
        self.logger.log("Language changed to {language}", "INFO", language=lang_name_local)
    def _refresh_ui_texts(self):
        try:
            # Обновляем заголовки и кнопки
            self.btn_load.configure(text=f"📂 {self._tr('Load Project')}")
            self.btn_build.configure(text=self._tr("⚡ Build"))
            if hasattr(self, 'btn_html5_config_top'):
                self.btn_html5_config_top.configure(text=self._tr("Edit Config"))
            if hasattr(self, 'btn_html5_config'):
                self.btn_html5_config.configure(text=self._tr("Configure HTML5"))
            self.lbl_manual.configure(text=self._tr("Manual Actions"))
            self.btn_open_deps.configure(text=self._tr("Open dependencies folder"))
            self.btn_recheck.configure(text=self._tr("Re-check deps"))
            self.btn_clear_logs.configure(text=self._tr("Clear logs"))
            self.btn_delete_projects.configure(text=self._tr("Delete all project folders"))
            
            
            # Обновляем надписи в заголовке
            if hasattr(self, 'lbl_project_type'):
                self.lbl_project_type.configure(text=self._tr("Project type:"))
            if hasattr(self, 'lbl_build'):
                self.lbl_build.configure(text=self._tr("Build:"))
            
            # Обновляем надпись "Language"
            if hasattr(self, 'lang_label'):
                self.lang_label.configure(text=self._tr("Language"))
            
            # Обновляем подсказку
            self.hint_var.set(self._tr("Tip: For Cordova, upload a ZIP with config.xml at root. For Android Studio, select project folder with gradlew. For HTML5, select a folder with index.html."))
            
            # Обновляем информацию о проекте
            current_project_info = self.project_info_var.get()
            if current_project_info == "No project loaded" or current_project_info == "Проект не загружен":
                self.project_info_var.set(self._tr("No project loaded"))
            elif current_project_info.startswith("Проект загружен:") or current_project_info.startswith("Project loaded:"):
                # Извлекаем путь и переводим только префикс
                if ":" in current_project_info:
                    path = current_project_info.split(":", 1)[1].strip()
                    self.project_info_var.set(f"{self._tr('Project loaded')}: {path}")
            
            # Обновляем статус keystore
            current_ks = self.ks_path_var.get()
            if current_ks == "Not selected" or current_ks == "Не выбран":
                self.ks_path_var.set(self._tr("Not selected"))
            
            # Обновляем текущую задачу
            current_task = self.current_task.get()
            if current_task and current_task != "Ready" and current_task != "Готово":
                # Пытаемся перевести текущую задачу
                try:
                    self.current_task.set(self._tr(current_task))
                except:
                    pass
            
            # Обновляем заголовки в секции подписи
            if hasattr(self, 'lbl_ks'):
                self.lbl_ks.configure(text=self._tr("Signing"))
            if hasattr(self, 'lbl_ks_path'):
                self.lbl_ks_path.configure(text=self._tr("Keystore"))
            if hasattr(self, 'lbl_alias'):
                self.lbl_alias.configure(text=self._tr("Key alias"))
            if hasattr(self, 'checkbox_show'):
                self.checkbox_show.configure(text=self._tr("Show passwords"))
            if hasattr(self, 'lbl_ks_pass'):
                self.lbl_ks_pass.configure(text=self._tr("Keystore Password"))
            if hasattr(self, 'lbl_key_pass'):
                self.lbl_key_pass.configure(text=self._tr("Key password (optional)"))
            
            # Обновляем кнопки в секции подписи
            if hasattr(self, 'btn_choose_ks'):
                self.btn_choose_ks.configure(text=self._tr("Choose"))
            if hasattr(self, 'btn_create_ks'):
                self.btn_create_ks.configure(text=self._tr("Create"))
            if hasattr(self, 'btn_clear_ks'):
                self.btn_clear_ks.configure(text=self._tr("Clear"))
            
            # Обновляем заголовки в секции логов
            if hasattr(self, 'lbl_logs'):
                self.lbl_logs.configure(text=self._tr("Logs (compact)"))
            
            # Обновляем кнопки в секции логов
            if hasattr(self, 'btn_save_logs'):
                self.btn_save_logs.configure(text=self._tr("Save Logs"))
            if hasattr(self, 'btn_copy_logs'):
                self.btn_copy_logs.configure(text=self._tr("Copy Logs"))
            if hasattr(self, 'btn_open_logs'):
                self.btn_open_logs.configure(text=self._tr("Open log folder"))
            
        except Exception as e:
            self.logger.log("Error updating UI texts: {err}", "ERROR", err=str(e))
    def _toggle_show_pass(self):
        show = "" if self.show_pass_var.get() else "*"
        self.entry_ks_pass.configure(show=show)
        self.entry_key_pass.configure(show=show)
    def _update_keystore_info(self, *args):
        path = self.ks_path_var.get()
        if path != self._tr("Not selected"):
            self.keystore_info["path"] = path
        self.keystore_info["alias"] = self.alias_var.get()
        self.keystore_info["storepass"] = self.ks_pass_var.get()
        self.keystore_info["keypass"] = self.key_pass_var.get() or self.ks_pass_var.get()
    def _choose_keystore(self):
        # Используем стандартный проводник файлов для выбора keystore файлов
        ks = filedialog.askopenfilename(
            title=self._tr("Select Keystore"),
            filetypes=[("Keystore files", "*.jks *.keystore"), ("All files", "*.*")]
        )
        if ks:
            self.ks_path_var.set(ks)
            self.logger.log("Keystore selected: {path}", "SUCCESS", path=ks)
    def _create_keystore_dialog(self):
        if hasattr(self, 'keystore_dialog') and self.keystore_dialog and self.keystore_dialog.winfo_exists():
            self.keystore_dialog.focus()
            return
        self.keystore_dialog = ctk.CTkToplevel(self)
        self.keystore_dialog.title(self._tr("Create a new keystore"))
        self.keystore_dialog.resizable(False, False)
        self.keystore_dialog.protocol("WM_DELETE_WINDOW", self._on_keystore_dialog_close)
        pad = 10
        # Scrollable frame for fields
        scroll_frame = ctk.CTkScrollableFrame(self.keystore_dialog)
        scroll_frame.pack(fill="both", expand=True, padx=pad, pady=pad)
        # Поля
        lbl_name = ctk.CTkLabel(scroll_frame, text=self._tr("First and Last Name"))
        lbl_name.pack(pady=(pad, 0), anchor="w")
        entry_name = ctk.CTkEntry(scroll_frame)
        entry_name.pack(fill="x")
        lbl_unit = ctk.CTkLabel(scroll_frame, text=self._tr("Organizational Unit"))
        lbl_unit.pack(pady=(pad, 0), anchor="w")
        entry_unit = ctk.CTkEntry(scroll_frame)
        entry_unit.pack(fill="x")
        lbl_org = ctk.CTkLabel(scroll_frame, text=self._tr("Organization"))
        lbl_org.pack(pady=(pad, 0), anchor="w")
        entry_org = ctk.CTkEntry(scroll_frame)
        entry_org.pack(fill="x")
        lbl_city = ctk.CTkLabel(scroll_frame, text=self._tr("City or Locality"))
        lbl_city.pack(pady=(pad, 0), anchor="w")
        entry_city = ctk.CTkEntry(scroll_frame)
        entry_city.pack(fill="x")
        lbl_state = ctk.CTkLabel(scroll_frame, text=self._tr("State or Province"))
        lbl_state.pack(pady=(pad, 0), anchor="w")
        entry_state = ctk.CTkEntry(scroll_frame)
        entry_state.pack(fill="x")
        lbl_country = ctk.CTkLabel(scroll_frame, text=self._tr("Country Code (XX)"))
        lbl_country.pack(pady=(pad, 0), anchor="w")
        entry_country = ctk.CTkEntry(scroll_frame)
        entry_country.pack(fill="x")
        lbl_alias = ctk.CTkLabel(scroll_frame, text=self._tr("Alias"))
        lbl_alias.pack(pady=(pad, 0), anchor="w")
        entry_alias = ctk.CTkEntry(scroll_frame)
        entry_alias.pack(fill="x")
        lbl_validity = ctk.CTkLabel(scroll_frame, text=self._tr("Validity (years)"))
        lbl_validity.pack(pady=(pad, 0), anchor="w")
        entry_validity = ctk.CTkEntry(scroll_frame)
        entry_validity.pack(fill="x")
        lbl_ks_pass = ctk.CTkLabel(scroll_frame, text=self._tr("Keystore Password"))
        lbl_ks_pass.pack(pady=(pad, 0), anchor="w")
        entry_ks_pass = ctk.CTkEntry(scroll_frame, show="*")
        entry_ks_pass.pack(fill="x")
        lbl_confirm_pass = ctk.CTkLabel(scroll_frame, text=self._tr("Confirm Password"))
        lbl_confirm_pass.pack(pady=(pad, 0), anchor="w")
        entry_confirm_pass = ctk.CTkEntry(scroll_frame, show="*")
        entry_confirm_pass.pack(fill="x")
        lbl_key_pass = ctk.CTkLabel(scroll_frame, text=self._tr("Key Password (optional, if different)"))
        lbl_key_pass.pack(pady=(pad, 0), anchor="w")
        entry_key_pass = ctk.CTkEntry(scroll_frame, show="*")
        entry_key_pass.pack(fill="x")
        # Buttons frame at bottom
        buttons = ctk.CTkFrame(self.keystore_dialog)
        buttons.pack(fill="x", side="bottom", pady=pad, padx=pad)
        btn_create = ctk.CTkButton(buttons, text=self._tr("Confirm"), command=lambda: self._create_keystore(
            self.keystore_dialog, entry_name.get(), entry_unit.get(), entry_org.get(), entry_city.get(), entry_state.get(), entry_country.get(),
            entry_alias.get(), entry_validity.get(), entry_ks_pass.get(), entry_confirm_pass.get(), entry_key_pass.get()
        ))
        btn_create.pack(side="left", padx=pad)
        btn_cancel = ctk.CTkButton(buttons, text=self._tr("Cancel"), command=self._on_keystore_dialog_close)
        btn_cancel.pack(side="left", padx=pad)
        
        # Set icon AFTER all widgets are created to prevent interference
        set_window_icon(self.keystore_dialog)
        
        # Теперь позиционируем окно в координатах курсора ПОСЛЕ создания всех виджетов
        self.keystore_dialog.update_idletasks()  # Обновляем геометрию виджетов
        
        # Получаем координаты курсора мыши
        x = self.winfo_pointerx()
        y = self.winfo_pointery()
        
        # Размеры окна
        window_width = 400
        window_height = 500
        
        # Вычисляем позицию так, чтобы окно было центрировано относительно курсора
        pos_x = x - (window_width // 2)
        pos_y = y - (window_height // 2)
        
        # Устанавливаем позицию и размер окна
        self.keystore_dialog.geometry(f"{window_width}x{window_height}+{pos_x}+{pos_y}")
        
        # Делаем окно поверх всех остальных окон
        self.keystore_dialog.lift()  # Поднимаем окно наверх
        self.keystore_dialog.focus_force()  # Принудительно фокусируемся на окне
        
        # Дополнительно поднимаем окно наверх через небольшую задержку
        self.keystore_dialog.after(50, lambda: self.keystore_dialog.lift())
        self.keystore_dialog.after(100, lambda: self.keystore_dialog.focus_force())
    def _on_keystore_dialog_close(self):
        if self.keystore_dialog:
            self.keystore_dialog.destroy()
            self.keystore_dialog = None
    def _create_keystore(self, dialog, name, unit, org, city, state, country, alias, validity, ks_pass, confirm_pass, key_pass):
        if ks_pass != confirm_pass:
            self._show_message(self._tr("Error"), self._tr("Passwords do not match"), "error")
            return
        if not all([name, unit, org, city, state, country, alias, validity, ks_pass]):
            self._show_message(self._tr("Error"), self._tr("Fill all required fields"), "error")
            return
        try:
            validity_days = int(validity) * 365
            if validity_days <= 0:
                raise ValueError("Validity must be positive")
        except ValueError:
            self._show_message(self._tr("Error"), self._tr("Validity must be a number"), "error")
            return
        if len(country) != 2:
            self._show_message(self._tr("Error"), self._tr("Country code must be 2 letters"), "error")
            return
        
        # Temporarily disable the dialog to prevent multiple clicks
        dialog.configure(state="disabled")
        
        ks_path = filedialog.asksaveasfilename(
            title=self._tr("Save Keystore"),
            defaultextension=".jks",
            filetypes=[("Keystore", "*.jks")]
        )
        
        # Re-enable the dialog and bring it to front
        dialog.configure(state="normal")
        dialog.focus_force()
        dialog.lift()
        
        # Small delay to ensure proper focus restoration
        dialog.after(100, lambda: dialog.focus_force())
        
        if not ks_path:
            return
        dname = f"CN={name}, OU={unit}, O={org}, L={city}, ST={state}, C={country}"
        keytool = os.path.join(self.DEP_DIR, "jdk", "bin", "keytool.exe" if platform.system() == "Windows" else "keytool")
        cmd = [
            keytool, "-genkey", "-v", "-keystore", ks_path, "-keyalg", "RSA", "-keysize", "2048",
            "-validity", str(validity_days), "-alias", alias, "-dname", dname,
            "-storepass", ks_pass, "-keypass", key_pass or ks_pass
        ]
        rc = self._run_and_stream(cmd)
        if rc == 0:
            self.ks_path_var.set(ks_path)
            self.alias_var.set(alias)
            self.ks_pass_var.set(ks_pass)
            self.key_pass_var.set(key_pass or ks_pass)
            self.logger.log("Keystore created: {path}", "SUCCESS", path=ks_path)
            self._on_keystore_dialog_close()
        else:
            self._show_message(self._tr("Error"), self._tr("Keystore creation failed"), "error")
    def _clear_keystore(self):
        self.ks_path_var.set(self._tr("Not selected"))
        self.alias_var.set("")
        self.ks_pass_var.set("")
        self.key_pass_var.set("")
        self.keystore_info = {}
        self.logger.log("Keystore cleared", "INFO")
    def _animate_progress(self):
        """Плавно изменяет значение прогресс-бара к target_progress."""
        if abs(self.current_progress - self.target_progress) < 0.5: # Порог останова
            self.current_progress = self.target_progress
            self.progress['value'] = self.current_progress
            self.global_percent.configure(text=f"{int(self.current_progress)}%")
            self.progress_animation_id = None
            return

        # Вычисляем шаг анимации (например, 1% за итерацию или 5% разницы)
        step = (self.target_progress - self.current_progress) * 0.1 # 10% разницы за шаг
        if abs(step) < 0.1: # Минимальный шаг
            step = 1 if self.target_progress > self.current_progress else -1
        self.current_progress += step
        self.progress['value'] = self.current_progress
        self.global_percent.configure(text=f"{int(self.current_progress)}%")
        
        # Планируем следующий шаг анимации
        self.progress_animation_id = self.after(20, self._animate_progress) # ~50 FPS

    def _set_progress(self, pct, task=None):
        try:
            # Ограничиваем значение между 0 и 100
            pct = max(0, min(100, pct))
            self.target_progress = pct # Устанавливаем целевое значение
            
            # Останавливаем предыдущую анимацию, если она была
            if self.progress_animation_id:
                self.after_cancel(self.progress_animation_id)
            
            # Запускаем новую анимацию
            self._animate_progress()

            # Обновляем текст текущей задачи
            if task:
                self.current_task.set(task)

        except Exception:
            pass

    def load_project(self):
        try:
            if self.project_internal_var.get() == "Android Studio":
                # Для Android Studio нужно выбрать папку, а не файл
                path = filedialog.askdirectory(title=self._tr("Select Project Directory"))
            else:
                # Для Cordova и HTML5 выбираем ZIP
                path = filedialog.askopenfilename(
                    title=self._tr("Select Project ZIP"),
                    filetypes=[("ZIP files", "*.zip"), ("All files", "*.*")]
                )
            if not path:
                return
            if path.endswith(".zip"):
                if self.project_internal_var.get() == "Cordova":
                    self._load_cordova_zip(path)
                elif self.project_internal_var.get() == "HTML5":
                    self._load_html5_zip(path)
                else:
                    self._load_project_folder(path)
            else:
                self._load_project_folder(path)
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
    def _load_cordova_zip(self, zip_path):
        try:
            self.logger.log("Loading Cordova ZIP: {zip}", "INFO", zip=zip_path)
            self._set_progress(5, self._tr("Loading ZIP archive..."))
            archive_name = os.path.splitext(os.path.basename(zip_path))[0]
            target = os.path.join(self.PROJ_DIR, archive_name)
            # Если проект с таким именем уже существует — удаляем и создаём заново
            try:
                if os.path.exists(target):
                    self.logger.log("Existing project folder detected, replacing: {dir}", "WARNING", dir=target)
                    shutil.rmtree(target)
            except Exception as _e:
                self.logger.log("Warning: Could not remove existing project folder: {error}", "WARNING", error=str(_e))
            safe_makedirs(target)
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                total_files = len(zip_ref.namelist())
                extracted_files = 0
                for file in zip_ref.namelist():
                    zip_ref.extract(file, target)
                    extracted_files += 1
                    progress = 5 + (extracted_files / total_files * 10)  # 10% for extraction
                    self._set_progress(progress, self._tr("Extracting ZIP archive... {percent}%", percent=int(extracted_files / total_files * 100)))
            # Fix directory structure if needed
            inner_dirs = [d for d in os.listdir(target) if os.path.isdir(os.path.join(target, d))]
            if len(inner_dirs) == 1 and os.path.exists(os.path.join(target, inner_dirs[0], "config.xml")):
                inner = os.path.join(target, inner_dirs[0])
                for item in os.listdir(inner):
                    shutil.move(os.path.join(inner, item), target)
                shutil.rmtree(inner)
                self.logger.log("Flattening inner directory {inner} → {dir}", "INFO", inner=inner, dir=target)
                self._set_progress(20, self._tr("Preparing project..."))
            self.project_path = target
            if os.path.exists(os.path.join(target, "config.xml")):
                self.project_loaded = True
                self.project_info_var.set(f"{self._tr('Project loaded')}: {target}")
                self.btn_build.configure(state="normal")
                self.logger.log("Cordova project loaded and validated (config.xml found)", "SUCCESS")
                self._set_progress(25, self._tr("Project ready for build"))
            else:
                self.logger.log("Error: {err}", "ERROR", err="config.xml not found in ZIP")
                self.project_loaded = False
                self.project_info_var.set(self._tr("No project loaded"))
                self.btn_build.configure(state="disabled")
                self._set_progress(0, self._tr("Project loading error"))
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
            self.project_loaded = False
            self.project_info_var.set(self._tr("No project loaded"))
            self.btn_build.configure(state="disabled")
            self._set_progress(0, self._tr("Project loading error"))
    def _load_html5_zip(self, zip_path):
        try:
            self.logger.log("Loading Cordova ZIP: {zip}", "INFO", zip=zip_path)
            self._set_progress(5, self._tr("Loading ZIP archive..."))
            archive_name = os.path.splitext(os.path.basename(zip_path))[0]
            target = os.path.join(self.PROJ_DIR, archive_name)
            # Если проект с таким именем уже существует — удаляем и создаём заново
            try:
                if os.path.exists(target):
                    self.logger.log("Existing project folder detected, replacing: {dir}", "WARNING", dir=target)
                    shutil.rmtree(target)
            except Exception as _e:
                self.logger.log("Warning: Could not remove existing project folder: {error}", "WARNING", error=str(_e))
            safe_makedirs(target)
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                total_files = len(zip_ref.namelist())
                extracted_files = 0
                for file in zip_ref.namelist():
                    zip_ref.extract(file, target)
                    extracted_files += 1
                    progress = 5 + (extracted_files / total_files * 10)
                    self._set_progress(progress, self._tr("Extracting ZIP archive... {percent}%", percent=int(extracted_files / total_files * 100)))
            # Flatten if single root dir containing index.html
            inner_dirs = [d for d in os.listdir(target) if os.path.isdir(os.path.join(target, d))]
            if len(inner_dirs) == 1 and os.path.exists(os.path.join(target, inner_dirs[0], "index.html")):
                inner = os.path.join(target, inner_dirs[0])
                for item in os.listdir(inner):
                    shutil.move(os.path.join(inner, item), target)
                shutil.rmtree(inner)
                self.logger.log("Flattening inner directory {inner} → {dir}", "INFO", inner=inner, dir=target)
                self._set_progress(20, self._tr("Preparing project..."))
            self.project_path = target
            if os.path.exists(os.path.join(target, "index.html")):
                self.project_loaded = True
                self.project_info_var.set(f"{self._tr('Project loaded')}: {target}")
                # Блокируем сборку до конфигурации проекта
                self.btn_build.configure(state="disabled")
                self.html5_pending_config = True
                # Показываем кнопку «Configure HTML5»
                try:
                    # Ensure buttons are shown with correct relative placement
                    self.btn_html5_config.pack_configure(anchor="w", padx=8, pady=(4,8))
                    # Always place top button 50px to the right of Build button
                    self.btn_html5_config_top.pack_forget()
                    self.btn_html5_config_top.pack(in_=self.winfo_children()[0], side="left", after=self.btn_build, padx=(3, 3))
                except Exception:
                    pass
                self.logger.log("HTML5 project loaded and validated (index.html found)", "SUCCESS")
                self._set_progress(25, self._tr("Project ready for build"))
                # Открываем окно конфигурации HTML5 → Cordova
                self.after(100, lambda: self._open_html5_config_dialog())
            else:
                self.logger.log("Error: {err}", "ERROR", err="index.html not found in ZIP")
                self.project_loaded = False
                self.project_info_var.set(self._tr("No project loaded"))
                self.btn_build.configure(state="disabled")
                self._set_progress(0, self._tr("Project loading error"))
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
            self.project_loaded = False
            self.project_info_var.set(self._tr("No project loaded"))
            self.btn_build.configure(state="disabled")
            self._set_progress(0, self._tr("Project loading error"))
    def _load_project_folder(self, folder):
        try:
            self.project_path = folder
            gradlew = os.path.join(folder, "gradlew.bat" if platform.system() == "Windows" else "gradlew")
            index_html = os.path.join(folder, "index.html")
            if os.path.exists(gradlew):
                self.project_loaded = True
                self.project_info_var.set(f"{self._tr('Project loaded')}: {folder}")
                self.btn_build.configure(state="normal")
                self.logger.log("Android Studio project loaded and validated (gradlew found)", "SUCCESS")
                self._set_progress(25, self._tr("Project ready for build"))
            elif os.path.exists(index_html):
                # HTML5 project detected
                self.project_loaded = True
                self.project_info_var.set(f"{self._tr('Project loaded')}: {folder}")
                self.btn_build.configure(state="disabled")
                self.html5_pending_config = True
                try:
                    self.btn_html5_config.pack_configure(anchor="w", padx=8, pady=(4,8))
                    self.btn_html5_config_top.pack_forget()
                    self.btn_html5_config_top.pack(in_=self.winfo_children()[0], side="left", after=self.btn_build, padx=(50, 10))
                except Exception:
                    pass
                self.logger.log("HTML5 project loaded and validated (index.html found)", "SUCCESS")
                self._set_progress(25, self._tr("Project ready for build"))
            else:
                self.logger.log("Error: {err}", "ERROR", err="gradlew or index.html not found in folder")
                self.project_loaded = False
                self.project_info_var.set(self._tr("No project loaded"))
                self.btn_build.configure(state="disabled")
                self._set_progress(0, self._tr("Project loading error"))
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
            self.project_loaded = False
            self.project_info_var.set(self._tr("No project loaded"))
            self.btn_build.configure(state="disabled")
            self._set_progress(0, self._tr("Project loading error"))


    def check_dependencies(self):
        self.after(0, lambda: self.btn_load.configure(state="disabled"))
        self.logger.log("Checking dependencies...", "INFO")
        self._set_progress(2, self._tr("Checking dependencies..."))
        node_dir = os.path.join(self.DEP_DIR, "node")
        jdk_dir = os.path.join(self.DEP_DIR, "jdk")
        sdk_tools_dir = os.path.join(self.DEP_DIR, "android-sdk", "cmdline-tools", "latest")
        gradle_dir = os.path.join(self.DEP_DIR, "gradle")
        cordova_dir = os.path.join(self.DEP_DIR, "node", "node_modules", "cordova")
        missing = []
        node_exe = os.path.join(node_dir, "node.exe" if platform.system() == "Windows" else "bin/node")
        java_exe = os.path.join(jdk_dir, "bin", "java.exe" if platform.system() == "Windows" else "bin/java")
        sdkmanager_exe = os.path.join(sdk_tools_dir, "bin", "sdkmanager.bat" if platform.system() == "Windows" else "sdkmanager")
        gradle_exe = os.path.join(gradle_dir, "bin", "gradle.bat" if platform.system() == "Windows" else "bin/gradle")
        cordova_exe = os.path.join(cordova_dir, "bin", "cordova")
        if not os.path.exists(node_exe):
            missing.append("Node.js")
        if not os.path.exists(java_exe):
            missing.append("JDK")
        if not os.path.exists(sdkmanager_exe):
            missing.append("Android SDK command-line tools")
        if not os.path.exists(gradle_exe):
            missing.append("Gradle")
        if not os.path.exists(cordova_exe):
            missing.append("Cordova CLI")
        if missing:
            self.logger.log("Missing: {name} ({path})", "WARNING", name=", ".join(missing), path=self.DEP_DIR)
            self.logger.log("Will install: {list}", "INFO", list=", ".join(missing))
            self._install_dependencies(missing)
        else:
            self.logger.log("Found: {name} ({path})", "SUCCESS", name="All dependencies", path=self.DEP_DIR)
            self.dependencies_installed = True
            self._setup_environment()
            self.logger.log("All dependencies installed and environment configured", "SUCCESS")
            self._set_progress(100, self._tr("Ready"))
        self.after(0, lambda: self.btn_load.configure(state="normal" if self.dependencies_installed else "disabled"))
    

    def _install_dependencies(self, missing):
        try:
            total_weight = sum(self.dependency_weights[dep] for dep in missing)
            current_progress = 5
            for dep in missing:
                self.logger.log("Installing dependency: {name}", "INFO", name=dep)
                self._set_progress(current_progress, self._tr("Installing {dep}...", dep=dep))
                if dep == "Node.js":
                    self._install_node(current_progress, self.dependency_weights[dep], total_weight)
                elif dep == "JDK":
                    self._install_jdk(current_progress, self.dependency_weights[dep], total_weight)
                elif dep == "Android SDK command-line tools":
                    self._install_sdk_tools(current_progress, self.dependency_weights[dep], total_weight)
                elif dep == "Gradle":
                    self._install_gradle(current_progress, self.dependency_weights[dep], total_weight)
                elif dep == "Cordova CLI":
                    self._install_cordova(current_progress, self.dependency_weights[dep], total_weight)
                current_progress += self.dependency_weights[dep]
                self._set_progress(current_progress, self._tr("{dep} installed", dep=dep))
            self.dependencies_installed = True
            self._setup_environment()
            self.logger.log("All dependencies installed and environment configured", "SUCCESS")
            self._set_progress(100, self._tr("Ready"))
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
            self._set_progress(0, self._tr("Ready"))
    def _install_node(self, start_progress, weight, total_weight):
        try:
            node_url = ("https://nodejs.org/dist/v18.16.0/node-v18.16.0-win-x64.zip" if platform.system() == "Windows" 
                       else "https://nodejs.org/dist/v18.16.0/node-v18.16.0-linux-x64.tar.xz")
            node_dir = os.path.join(self.DEP_DIR, "node")
            self._download_and_extract(node_url, node_dir, "Node.js", start_progress, weight, total_weight)
            self._flatten_dir(node_dir)
            self.logger.log("Installed Node.js: {version}", "SUCCESS", version=self._get_node_version())
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
    def _install_jdk(self, start_progress, weight, total_weight):
        try:
            jdk_url = ("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.2%2B8/OpenJDK17U-jdk_x64_windows_hotspot_17.0.2_8.zip" 
                      if platform.system() == "Windows" 
                      else "https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.2%2B8/OpenJDK17U-jdk_x64_linux_hotspot_17.0.2_8.tar.gz")
            jdk_dir = os.path.join(self.DEP_DIR, "jdk")
            self._download_and_extract(jdk_url, jdk_dir, "JDK", start_progress, weight, total_weight)
            self._flatten_dir(jdk_dir)
            self.logger.log("Installed JDK: {version}", "SUCCESS", version=self._get_jdk_version())
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
    def _install_sdk_tools(self, start_progress, weight, total_weight):
        try:
            sdk_url = ("https://dl.google.com/android/repository/commandlinetools-win-9477386_latest.zip" 
                      if platform.system() == "Windows" 
                      else "https://dl.google.com/android/repository/commandlinetools-linux-9477386_latest.zip")
            sdk_tools_dir = os.path.join(self.DEP_DIR, "android-sdk", "cmdline-tools")
            self._download_and_extract(sdk_url, sdk_tools_dir, "Android SDK command-line tools", start_progress, weight, total_weight)
            self._fix_sdk_structure(sdk_tools_dir)
            sdk_dir = os.path.join(self.DEP_DIR, "android-sdk")
            self._accept_sdk_licenses(sdk_dir, start_progress + weight * 0.3, weight * 0.2, total_weight)
            self._install_sdk_components(sdk_dir, start_progress + weight * 0.5, weight * 0.5, total_weight)
            self.logger.log("Android SDK command-line tools installed to {path}", "SUCCESS", path=sdk_dir)
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
    def _install_gradle(self, start_progress, weight, total_weight):
        try:
            gradle_url = "https://services.gradle.org/distributions/gradle-7.6-bin.zip"
            gradle_dir = os.path.join(self.DEP_DIR, "gradle")
            self._download_and_extract(gradle_url, gradle_dir, "Gradle", start_progress, weight, total_weight)
            self._flatten_dir(gradle_dir)
            self.logger.log("Installed Gradle: {version}", "SUCCESS", version="7.6")
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
    def _install_cordova(self, start_progress, weight, total_weight):
        try:
            self.logger.log("Installing Cordova CLI locally", "INFO")
            self._set_progress(start_progress, self._tr("Installing Cordova CLI locally"))
            
            node_dir = os.path.join(self.DEP_DIR, "node")
            node_exe = os.path.join(node_dir, "node.exe" if platform.system() == "Windows" else "bin/node")
            npm_cli_path = ensure_npm_cli(node_dir, self.logger)
            if not os.path.exists(npm_cli_path):
                raise Exception("npm-cli.js not found even after bootstrap")

            if not os.path.exists(node_exe):
                raise Exception("node.exe not found; cannot install Cordova")
            
            env = self._get_env()
            cmd = [node_exe, npm_cli_path, "install", "cordova@12.0.0", "--no-save"]
            
            # Для установки Cordova используем старый метод без скрытия окна
            self.logger.log("Executing: {cmd}", "DEBUG", cmd=" ".join(cmd))
            shell = platform.system() == "Windows"
            proc = subprocess.Popen(cmd, cwd=node_dir, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE, 
                                 text=True, env=env, bufsize=1, shell=shell)
            try:
                while True:
                    line = proc.stdout.readline()
                    if not line and proc.poll() is not None:
                        break
                    if line:
                        self.logger.raw(line.rstrip("\n"))
                rc = proc.wait(timeout=600)  # Увеличиваем timeout до 10 минут
            except subprocess.TimeoutExpired:
                try:
                    proc.terminate()
                    proc.wait(timeout=3)
                except Exception:
                    pass
                self.logger.log("Error: {err}", "ERROR", err="Command timeout")
                return
            if rc == 0:
                self.logger.log("Command finished successfully (code {rc})", "SUCCESS", rc=rc)
            else:
                self.logger.log("Command finished with code {rc}", "ERROR", rc=rc)
            
            self._set_progress(start_progress + weight * 0.5, self._tr("Installing Cordova CLI locally"))
            if rc == 0:
                cordova_exe = os.path.join(node_dir, "node_modules", "cordova", "bin", "cordova")
                if os.path.exists(cordova_exe):
                    self.logger.log("Cordova CLI installed: {version}", "SUCCESS", version="12.0.0")
                    self._set_progress(start_progress + weight, self._tr("Cordova CLI installed"))
                else:
                    self.logger.log("Error: {err}", "ERROR", err="Cordova installation failed; binary not found")
            else:
                self.logger.log("Error: {err}", "ERROR", err=f"Cordova installation failed with code {rc}")
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
    def _download_and_extract(self, url, target_dir, description, start_progress, weight, total_weight):
        try:
            self.logger.log("Downloading {description} from {url}", "INFO", description=description, url=url)
            self._set_progress(start_progress, self._tr("Downloading {description}...", description=description))
            response = requests.get(url, stream=True, timeout=30)
            response.raise_for_status()
            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0
            start_time = time.time()
            last_update_time = start_time
            last_downloaded = 0
            ext = url.split('?')[0].split('.')[-1]
            temp_file = os.path.join(self.DEP_DIR, f"temp_{description.replace(' ', '_')}.{ext}")
            
            # Сбрасываем отображение скорости
            self.after(0, lambda: self.download_speed_label.configure(text=self._tr("Speed: --")))
            self.after(0, lambda: self.download_eta_label.configure(text=self._tr("ETA: --")))
            
            with open(temp_file, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        current_time = time.time()
                        
                        # Обновляем скорость каждые 0.5 секунды
                        if current_time - last_update_time >= 0.5:
                            time_diff = current_time - last_update_time
                            downloaded_diff = downloaded - last_downloaded
                            
                            if time_diff > 0 and downloaded_diff > 0:
                                # Вычисляем скорость в МБ/с
                                speed_mbps = (downloaded_diff / time_diff) / (1024 * 1024)
                                speed_text = f"{speed_mbps:.2f} MB/s"
                                
                                # Вычисляем оставшееся время
                                if total_size > 0:
                                    remaining_bytes = total_size - downloaded
                                    eta_seconds = remaining_bytes / (downloaded_diff / time_diff) if downloaded_diff > 0 else 0
                                    eta_text = self._format_time(eta_seconds)
                                else:
                                    eta_text = "--"
                                
                                # Обновляем UI в главном потоке
                                self.after(0, lambda s=speed_text: self.download_speed_label.configure(text=self._tr("Speed: {speed}", speed=s)))
                                self.after(0, lambda e=eta_text: self.download_eta_label.configure(text=self._tr("ETA: {eta}", eta=e)))
                            
                            last_update_time = current_time
                            last_downloaded = downloaded
                        
                        if total_size > 0:
                            download_progress = start_progress + (downloaded / total_size) * (weight * 0.5)
                            percent = int(downloaded / total_size * 100)
                            self._set_progress(download_progress, self._tr("Downloading {description}... {percent}%", description=description, percent=percent))
            
            # Сбрасываем отображение скорости после завершения
            self.after(0, lambda: self.download_speed_label.configure(text=self._tr("Speed: --")))
            self.after(0, lambda: self.download_eta_label.configure(text=self._tr("ETA: --")))
            
            self.logger.log("Downloaded {description} → {path}", "INFO", description=description, path=temp_file)
            self._set_progress(start_progress + weight * 0.5, self._tr("Download completed"))
            self.logger.log("Extracting {description} to {target}...", "INFO", description=description, target=target_dir)
            safe_makedirs(target_dir)
            if temp_file.endswith(('.tar.gz', '.tar.xz', '.tar', '.gz', '.xz')):
                import tarfile
                with tarfile.open(temp_file, 'r:*') as tar_ref:
                    total_files = len(tar_ref.getnames())
                    extracted_files = 0
                    for member in tar_ref.getnames():
                        tar_ref.extract(member, target_dir)
                        extracted_files += 1
                        extract_progress = start_progress + weight * 0.5 + (extracted_files / total_files) * (weight * 0.5)
                        percent = int(extracted_files / total_files * 100)
                        self._set_progress(extract_progress, self._tr("Extracting {description}... {percent}%", description=description, percent=percent))
            else:
                with zipfile.ZipFile(temp_file, 'r') as zip_ref:
                    total_files = len(zip_ref.namelist())
                    extracted_files = 0
                    for file in zip_ref.namelist():
                        zip_ref.extract(file, target_dir)
                        extracted_files += 1
                        extract_progress = start_progress + weight * 0.5 + (extracted_files / total_files) * (weight * 0.5)
                        percent = int(extracted_files / total_files * 100)
                        self._set_progress(extract_progress, self._tr("Extracting {description}... {percent}%", description=description, percent=percent))
            self.logger.log("{description} installed to {target}", "SUCCESS", description=description, target=target_dir)
            self._set_progress(start_progress + weight, self._tr("{description} installed", description=description))
            try:
                os.remove(temp_file)
            except Exception:
                pass
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
            raise
    
    def _format_time(self, seconds):
        """Форматирует время в удобочитаемый вид"""
        if seconds < 0:
            return "--"
        elif seconds < 60:
            return f"{int(seconds)}s"
        elif seconds < 3600:
            minutes = int(seconds // 60)
            secs = int(seconds % 60)
            return f"{minutes}m {secs}s"
        else:
            hours = int(seconds // 3600)
            minutes = int((seconds % 3600) // 60)
            return f"{hours}h {minutes}m"
    
    def _flatten_dir(self, dir_path):
        try:
            inner_dirs = [d for d in os.listdir(dir_path) if os.path.isdir(os.path.join(dir_path, d))]
            if len(inner_dirs) == 1:
                inner = os.path.join(dir_path, inner_dirs[0])
                for item in os.listdir(inner):
                    src = os.path.join(inner, item)
                    dest = os.path.join(dir_path, item)
                    if os.path.exists(dest):
                        if os.path.isdir(dest):
                            shutil.rmtree(dest)
                        else:
                            os.remove(dest)
                    shutil.move(src, dest)
                shutil.rmtree(inner)
                self.logger.log("Flattening inner directory {inner} → {dir}", "INFO", inner=inner, dir=dir_path)
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
    def _get_node_version(self):
        try:
            node = os.path.join(self.DEP_DIR, "node", "node.exe" if platform.system() == "Windows" else "bin/node")
            if os.path.exists(node):
                out = subprocess.check_output([node, "--version"], text=True, timeout=5, startupinfo=get_hidden_startupinfo())
                return out.strip()
            return "unknown"
        except Exception:
            return "unknown"
    def _get_jdk_version(self):
        try:
            java = os.path.join(self.DEP_DIR, "jdk", "bin", "java.exe" if platform.system() == "Windows" else "bin/java")
            if os.path.exists(java):
                out = subprocess.check_output([java, "-version"], stderr=subprocess.STDOUT, text=True, timeout=5, startupinfo=get_hidden_startupinfo())
                for line in out.splitlines():
                    if "version" in line.lower():
                        return line.strip().split()[1].strip('"')
            return "unknown"
        except Exception:
            return "unknown"
    def _fix_sdk_structure(self, tools_dir):
        try:
            latest = os.path.join(tools_dir, "latest")
            safe_makedirs(latest)
            for item in os.listdir(tools_dir):
                if item == "latest":
                    continue
                p = os.path.join(tools_dir, item)
                if os.path.isdir(p) and "bin" in os.listdir(p):
                    for sub in os.listdir(p):
                        s = os.path.join(p, sub)
                        d = os.path.join(latest, sub)
                        if os.path.exists(d):
                            if os.path.isdir(d):
                                shutil.rmtree(d)
                            else:
                                os.remove(d)
                        shutil.move(s, d)
                    try:
                        shutil.rmtree(p)
                    except Exception:
                        pass
                    self.logger.log("Flattening inner directory {inner} → {dir}", "INFO", inner=p, dir=latest)
                    return
            if "bin" in os.listdir(tools_dir):
                for it in os.listdir(tools_dir):
                    if it == "latest":
                        continue
                    s = os.path.join(tools_dir, it)
                    d = os.path.join(latest, it)
                    if os.path.exists(d):
                        if os.path.isdir(d):
                            shutil.rmtree(d)
                        else:
                            os.remove(d)
                        shutil.move(s, d)
                self.logger.log("Flattening inner directory {inner} → {dir}", "INFO", inner=tools_dir, dir=latest)
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
    def _accept_sdk_licenses(self, sdk_dir, start_progress, weight, total_weight):
        try:
            self.logger.log("Accepting Android SDK licenses (writing license files + interactive sdkmanager)...", "INFO")
            self._set_progress(start_progress, self._tr("Accepting SDK licenses..."))
            licenses_dir = os.path.join(sdk_dir, "licenses")
            safe_makedirs(licenses_dir)
            license_files = {
                "android-sdk-license": "24333f8a63b6825ea9c5514f83c2829b004d1fee",
                "android-sdk-preview-license": "84831b9409646a918e30573b5c9c3cb0",
                "android-googletv-license": "601085b94cd77f0b54ff86406957099ebe79c4d6",
                "uiautomator-license": "8933bad161af4178b1185b1a37fbf41ea5269c11"
            }
            for fname, content in license_files.items():
                p = os.path.join(licenses_dir, fname)
                if not os.path.exists(p):
                    with open(p, "w") as f:
                        f.write(content)
                    self.logger.log("Created license file: {fname}", "DEBUG", fname=fname)
                else:
                    self.logger.log("License file exists: {fname}", "DEBUG", fname=fname)
            sdkmanager = self._get_sdkmanager_path()
            if not os.path.exists(sdkmanager):
                self.logger.log("Warning: {warn}", "WARNING", warn="sdkmanager not found, skipping interactive license acceptance")
                return
            env = self._get_env()
            cmd = [sdkmanager, "--licenses", f"--sdk_root={sdk_dir}"]
            proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, env=env, startupinfo=get_hidden_startupinfo())
            try:
                for _ in range(50):
                    try:
                        proc.stdin.write("y\n")
                        proc.stdin.flush()
                    except Exception:
                        pass
                    time.sleep(0.05)
                while True:
                    line = proc.stdout.readline()
                    if not line and proc.poll() is not None:
                        break
                    if line:
                        self.logger.raw(line.rstrip("\n"))
                rc = proc.wait(timeout=300)
                if rc == 0:
                    self.logger.log("sdkmanager accepted licenses (interactive)", "SUCCESS")
                else:
                    self.logger.log("Warning: {warn}", "WARNING", warn=f"sdkmanager returned {rc}")
                self._set_progress(start_progress + weight, self._tr("Licenses accepted"))
            except Exception as e:
                self.logger.log("Error: {err}", "ERROR", err=str(e))
                self.logger.raw(traceback.format_exc())
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
    def _install_sdk_components(self, sdk_dir, start_progress, weight, total_weight):
        try:
            sdkmanager = self._get_sdkmanager_path()
            if not os.path.exists(sdkmanager):
                raise Exception("sdkmanager not found")
            components = [
                "platform-tools",
                "platforms;android-33",
                "platforms;android-34",
                "build-tools;33.0.2"
            ]
            env = self._get_env()
            total_comps = len(components)
            comp_progress = weight / total_comps if total_comps > 0 else weight
            for i, comp in enumerate(components):
                self.logger.log("Installing Android SDK components (build-tools, platforms, platform-tools)...", "INFO")
                self.logger.log("Installing Android SDK component: {name}", "INFO", name=comp)
                self._set_progress(start_progress + i * comp_progress, self._tr("Installing component: {comp}...", comp=comp))
                cmd = [sdkmanager, "--verbose", comp, f"--sdk_root={sdk_dir}"]
                proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, env=env, startupinfo=get_hidden_startupinfo())
                try:
                    for _ in range(20):
                        try:
                            proc.stdin.write("y\n")
                            proc.stdin.flush()
                        except Exception:
                            pass
                        time.sleep(0.1)
                    while True:
                        line = proc.stdout.readline()
                        if not line and proc.poll() is not None:
                           break
                        if line:
                            self.logger.raw(line.rstrip("\n"))
                    rc = proc.wait(timeout=300)
                    if rc == 0:
                        self.logger.log("{description} installed to {target}", "SUCCESS", description=comp, target=sdk_dir)
                    else:
                        self.logger.log("Warning: {warn}", "WARNING", warn=f"{comp} install returned {rc}")
                    self._set_progress(start_progress + (i + 1) * comp_progress, self._tr("Component {comp} installed", comp=comp))
                except Exception as e:
                    self.logger.log("Error: {err}", "ERROR", err=str(e))
                    self.logger.raw(traceback.format_exc())
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
    def _get_sdkmanager_path(self):
        return os.path.join(self.DEP_DIR, "android-sdk", "cmdline-tools", "latest", "bin", 
                           "sdkmanager.bat" if platform.system() == "Windows" else "sdkmanager")
    def _setup_environment(self):
        try:
            env = os.environ.copy()
            env["JAVA_HOME"] = os.path.join(self.DEP_DIR, "jdk")
            env["ANDROID_HOME"] = os.path.join(self.DEP_DIR, "android-sdk")
            env["ANDROID_SDK_ROOT"] = env["ANDROID_HOME"]
            env["GRADLE_HOME"] = os.path.join(self.DEP_DIR, "gradle")
            parts = [
                os.path.join(env["GRADLE_HOME"], "bin"),
                os.path.join(self.DEP_DIR, "node" if platform.system() == "Windows" else "node/bin"),
                os.path.join(self.DEP_DIR, "node", "node_modules", "cordova", "bin"),
                os.path.join(env["JAVA_HOME"], "bin"),
                os.path.join(env["ANDROID_HOME"], "platform-tools"),
                os.path.join(env["ANDROID_HOME"], "cmdline-tools", "latest", "bin")
            ]
            parts.append(env.get("PATH", ""))
            env["PATH"] = os.pathsep.join(p for p in parts if p)
            self._cached_env = env
            self.logger.log("Environment variables configured:", "DEBUG")
            self.logger.log("  JAVA_HOME: {path}", "DEBUG", path=env["JAVA_HOME"])
            self.logger.log("  ANDROID_HOME: {path}", "DEBUG", path=env["ANDROID_HOME"])
            self.logger.log("  GRADLE_HOME: {path}", "DEBUG", path=env["GRADLE_HOME"])
            self.logger.log("  PATH (prefix): {path}", "DEBUG", path=(env["PATH"][:200] + "..."))
            self.logger.log("Environment setup complete", "SUCCESS")
            return True
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
            raise
    def _get_env(self):
        if self._cached_env:
            return self._cached_env
        self._setup_environment()
        return self._cached_env
    def _run_and_capture(self, cmd, cwd=None):
        try:
            env = self._get_env()
            completed = subprocess.run(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, env=env, encoding='utf-8', startupinfo=get_hidden_startupinfo())
            out = completed.stdout or ""
            for line in out.splitlines():
                self.logger.raw(line)
            return out
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
            raise
    def _run_and_stream(self, cmd, cwd=None, timeout=3600):
        try:
            cmd_display = " ".join(cmd) if isinstance(cmd, (list, tuple)) else str(cmd)
            self.logger.log("Executing: {cmd}", "DEBUG", cmd=cmd_display)
            env = self._get_env()
            shell = platform.system() == "Windows"
            proc = subprocess.Popen(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE, 
                                 text=True, env=env, bufsize=1, shell=shell, startupinfo=get_hidden_startupinfo())
            try:
                while True:
                    line = proc.stdout.readline()
                    if not line and proc.poll() is not None:
                        break
                    if line:
                        self.logger.raw(line.rstrip("\n"))
                rc = proc.wait(timeout=timeout)
            except subprocess.TimeoutExpired:
                try:
                    proc.terminate()
                    proc.wait(timeout=3)
                except Exception:
                    pass
                self.logger.log("Error: {err}", "ERROR", err="Command timeout")
                return -1
            if rc == 0:
                self.logger.log("Command finished successfully (code {rc})", "SUCCESS", rc=rc)
            else:
                self.logger.log("Command finished with code {rc}", "ERROR", rc=rc)
            return rc
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
            return -1
    def start_build(self):
        if not self.project_loaded:
            self._show_message(self._tr("Error"), self._tr("No project loaded"), "error")
            return
        if self.project_internal_var.get() == "Cordova" and not self.dependencies_installed:
            self._show_message(self._tr("Warning"), self._tr("Dependencies are still being installed. Wait or re-run after installation."), "warning")
            return
        mode_internal = self.build_internal_var.get()
        if mode_internal.startswith("Signed"):
            if not self.keystore_info.get("path") or not self.keystore_info.get("alias") or not self.keystore_info.get("storepass"):
                self._show_message(self._tr("Error"), self._tr("No keystore configured for signed build"), "error")
                return
        self.btn_build.configure(state="disabled")
        self._set_progress(0, self._tr("Starting build..."))
        threading.Thread(target=self._build_thread, daemon=True).start()
    def _build_thread(self):
        try:
            mode_internal = self.build_internal_var.get()
            project_type_internal = self.project_internal_var.get()
            self.logger.log("Build started: {mode} for {ptype}", "INFO", mode=mode_internal, ptype=project_type_internal)
            self._set_progress(2, self._tr("Starting build..."))
            # Если выбран HTML5 и конфиг завершён — собираем через Cordova, не меняя тип в UI
            if project_type_internal == "HTML5":
                if self.html5_pending_config:
                    self._show_message(self._tr("Info"), self._tr("Complete HTML5 config (Edit Config) to enable build."), "info")
                    self.logger.log("Build blocked: complete HTML5 config first", "WARNING")
                    return
                # Проверяем зависимости для Cordova-сборки
                if not self.dependencies_installed:
                    self._show_message(self._tr("Warning"), self._tr("Dependencies are still being installed. Wait or re-run after installation."), "warning")
                    return
                self.logger.log("HTML5 selected: packaging with Cordova without changing UI type", "INFO")
                self._build_cordova(mode_internal)
                return
            if project_type_internal == "Cordova":
                self._build_cordova(mode_internal)
            elif project_type_internal == "Android Studio":
                self._build_android_studio(mode_internal)
            self.logger.log("Build process completed (thread exit)", "INFO")
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())
        finally:
            self.btn_build.configure(state="normal")
            self._set_progress(100, self._tr("Build completed"))
            time.sleep(1)
            self._set_progress(0, self._tr("Ready"))
    def _build_cordova(self, mode_internal):
        self._set_progress(10, self._tr("Starting Cordova build..."))
        node_dir = os.path.join(self.DEP_DIR, "node")
        cordova_exe = os.path.join(node_dir, "node_modules", "cordova", "bin", "cordova")
        if not os.path.exists(cordova_exe):
            raise Exception("Cordova CLI not found in dependencies")
        cordova_cmd = cordova_exe
        self.logger.log("Using Cordova command: {cmd}", "INFO", cmd=cordova_cmd)
        cwd = self.project_path

        # Skip any project file mutations for Cordova builds (use project as-is)
        try:
            self.logger.log("Skipping project auto-fixes (using source as-is)", "INFO")
        except Exception:
            pass

        # If resources were updated, force platform refresh to regenerate icons/splash
        try:
            import json
            marker = os.path.join(cwd, '.cordova_assets.json')
            need_refresh = False
            if os.path.exists(marker):
                try:
                    with open(marker, 'r', encoding='utf-8') as f:
                        st = json.load(f)
                    need_refresh = bool(st.get('pendingResourceUpdate'))
                except Exception:
                    need_refresh = True
            if need_refresh:
                platforms_dir = os.path.join(cwd, 'platforms')
                android_platform_dir = os.path.join(platforms_dir, 'android')
                if os.path.exists(android_platform_dir):
                    try:
                        shutil.rmtree(android_platform_dir)
                        self.logger.log("Removed Android platform to refresh resources", "INFO")
                    except Exception as e:
                        self.logger.log("Warning: Could not remove platform for refresh: {error}", "WARNING", error=str(e))
                # try to run cordova-res if present to generate density-specific assets
                try:
                    node_exe = os.path.join(node_dir, "node.exe" if platform.system() == "Windows" else "bin/node")
                    npm_cli = ensure_npm_cli(node_dir, self.logger)
                    # install cordova-res locally (no-save)
                    if os.path.exists(node_exe) and os.path.exists(npm_cli):
                        self.logger.log("Installing cordova-res tool...", "INFO")
                        self._run_and_stream([node_exe, npm_cli, "install", "cordova-res@latest", "--no-save"], cwd=node_dir)
                        cordova_res_bin = os.path.join(node_dir, "node_modules", ".bin", "cordova-res.cmd" if platform.system()=="Windows" else "cordova-res")
                        if os.path.exists(cordova_res_bin):
                            self.logger.log("Running cordova-res to generate resources...", "INFO")
                            self._run_and_stream([cordova_res_bin, "android", "--skip-config"], cwd=cwd)
                except Exception as e:
                    self.logger.log("Warning: cordova-res failed: {error}", "WARNING", error=str(e))
                # Clear flag
                try:
                    with open(marker, 'w', encoding='utf-8') as f:
                        json.dump({'pendingResourceUpdate': False}, f)
                except Exception:
                    pass
        except Exception:
            pass

        # Создаём build.json ТОЛЬКО для подписанных режимов, иначе не создаём ничего
        build_json_path = None
        if mode_internal.startswith("Signed"):
            self._set_progress(15, self._tr("Creating build configuration..."))
            build_json_path = self._create_build_json(cwd, mode_internal)
            if build_json_path and os.path.exists(build_json_path):
                self.logger.log("build.json created and integrated into project: {path}", "SUCCESS", path=build_json_path)
                try:
                    import json
                    with open(build_json_path, 'r', encoding='utf-8') as f:
                        json.load(f)
                    self.logger.log("build.json content verified successfully", "SUCCESS")
                except Exception as e:
                    self.logger.log("Warning: build.json created but content verification failed: {error}", "WARNING", error=str(e))
            else:
                self.logger.log("Warning: Could not create build.json for signed build", "WARNING")

        # Добавление платформы через Cordova CLI
        platforms_dir = os.path.join(cwd, "platforms")
        android_platform_dir = os.path.join(platforms_dir, "android")
        
        # Проверяем, существует ли платформа и корректна ли она
        api_js_path = os.path.join(android_platform_dir, "cordova", "Api.js")
        if not os.path.exists(android_platform_dir) or not os.path.exists(api_js_path):
            self.logger.log("Android platform missing or corrupted, removing and re-adding...", "WARNING")
            # Удаляем поврежденную платформу
            if os.path.exists(android_platform_dir):
                try:
                    shutil.rmtree(android_platform_dir)
                    self.logger.log("Removed corrupted Android platform", "INFO")
                except Exception as e:
                    self.logger.log("Warning: Could not remove corrupted platform: {error}", "WARNING", error=str(e))
            
            self.logger.log("Adding Android platform to Cordova...", "INFO")
            self._set_progress(20, self._tr("Adding Android platform..."))
            # Обеспечиваем наличие npm
            npm_cli_path = ensure_npm_cli(node_dir, self.logger)
            if not os.path.exists(npm_cli_path):
                raise Exception("npm-cli.js not found even after bootstrap")
            # Команда cordova platform add
            node_exe = os.path.join(node_dir, "node.exe" if platform.system() == "Windows" else "bin/node")
            add_cmd = [node_exe, cordova_cmd, "platform", "add", "android@12.0.0", "--no-telemetry"]
            rc_add = self._run_and_stream(add_cmd, cwd=cwd)
            if rc_add != 0:
                raise Exception(f"Cordova platform add failed with code {rc_add}")
            self._set_progress(30, self._tr("Android platform added"))
        else:
            self.logger.log("Android platform already exists", "INFO")
            # Дополнительная проверка целостности платформы
            app_build_gradle = os.path.join(android_platform_dir, "app", "build.gradle")
            if not os.path.exists(app_build_gradle):
                self.logger.log("Warning: app/build.gradle not found, platform may be corrupted", "WARNING")
                # Попробуем пересоздать платформу
                self.logger.log("Attempting to fix platform by removing and re-adding...", "INFO")
                try:
                    shutil.rmtree(android_platform_dir)
                    self.logger.log("Removed corrupted Android platform", "INFO")
                    
                    # Добавляем платформу заново
                    npm_cli_path = ensure_npm_cli(node_dir, self.logger)
                    if not os.path.exists(npm_cli_path):
                        raise Exception("npm-cli.js not found even after bootstrap")
                    node_exe = os.path.join(node_dir, "node.exe" if platform.system() == "Windows" else "bin/node")
                    add_cmd = [node_exe, cordova_cmd, "platform", "add", "android@12.0.0", "--no-telemetry"]
                    rc_add = self._run_and_stream(add_cmd, cwd=cwd)
                    if rc_add != 0:
                        raise Exception(f"Cordova platform add failed with code {rc_add}")
                    self.logger.log("Android platform re-added successfully", "SUCCESS")
                except Exception as e:
                    self.logger.log("Warning: Could not fix platform: {error}", "WARNING", error=str(e))
            self._set_progress(30, self._tr("Android platform ready"))

        # Не применяем никаких патчей к проектным файлам
        self._set_progress(35, self._tr("Applying patches..."))
        
        # Не выполняем prepare/патч и не меняем gradle-конфигурации — как в чистой CLI
        # Сборка через Cordova CLI с использованием build.json
        node_exe = os.path.join(node_dir, "node.exe" if platform.system() == "Windows" else "bin/node")
        cmd = [node_exe, cordova_cmd, "build", "android", "--no-telemetry"]
        
        # Определяем, нужно ли использовать buildConfig
        use_build_config = (build_json_path and os.path.exists(build_json_path) and mode_internal.startswith("Signed"))
        if use_build_config:
            self.logger.log("Using buildConfig for signed build", "INFO")
            # Устанавливаем переменные окружения для keystore (альтернативный способ)
            ks = self.keystore_info
            if ks.get("path"):
                os.environ["CORDOVA_ANDROID_RELEASE_KEYSTORE"] = ks["path"]
                os.environ["CORDOVA_ANDROID_RELEASE_KEY_ALIAS"] = ks.get("alias", "")
                os.environ["CORDOVA_ANDROID_RELEASE_STORE_PASSWORD"] = ks.get("storepass", "")
                os.environ["CORDOVA_ANDROID_RELEASE_KEY_PASSWORD"] = ks.get("keypass", ks.get("storepass", ""))
                self.logger.log("Set environment variables for keystore as backup", "DEBUG")
        else:
            self.logger.log("Not using buildConfig - will use manual signing", "INFO")
        
        if mode_internal == "Debug APK":
            cmd.append("--debug")
        elif mode_internal == "Signed Debug APK":
            if use_build_config:
                cmd.extend(["--debug", "--buildConfig", build_json_path])
            else:
                cmd.append("--debug")
        elif mode_internal == "Unsigned Release APK":
            cmd.extend(["--release", "--", "--packageType=apk"])
        elif mode_internal == "Signed Release APK":
            if use_build_config:
                cmd.extend(["--release", "--buildConfig", build_json_path, "--", "--packageType=apk"])
            else:
                cmd.extend(["--release", "--", "--packageType=apk"])
        elif mode_internal == "Unsigned AAB":
            cmd.extend(["--release", "--", "--packageType=bundle"])
        elif mode_internal == "Signed AAB":
            if use_build_config:
                cmd.extend(["--release", "--buildConfig", build_json_path, "--", "--packageType=bundle"])
            else:
                cmd.extend(["--release", "--", "--packageType=bundle"])
        else:
            cmd.append("--release")
        self.logger.log("Running Cordova build: {cmd}", "INFO", cmd=" ".join(cmd))
        self._set_progress(40, self._tr("Build: {mode_internal}...", mode_internal=mode_internal))
        rc = self._run_and_stream(cmd, cwd=cwd)
        self._set_progress(70, self._tr("Build completed"))
        if rc != 0:
            self.logger.log("Cordova build failed, trying Android Studio build as fallback...", "WARNING")
            try:
                # Пробуем Android Studio сборку как fallback
                self._build_android_studio(mode_internal)
                return  # Если Android Studio сборка успешна, выходим
            except Exception as e:
                self.logger.log("Android Studio build also failed: {error}", "ERROR", error=str(e))
            raise Exception(f"Cordova build failed with code {rc}")
        artifacts = self._find_artifacts_cordova(cwd, mode_internal)
        self.logger.log("Found build artifacts: {paths}", "INFO", paths=", ".join(artifacts) if artifacts else "(none)")
        self._set_progress(80, self._tr("Artifacts found"))
        
        # Проверяем, что получили правильный тип файла
        if (mode_internal == "Unsigned Release APK" or mode_internal == "Signed Release APK" or mode_internal == "Debug APK" or mode_internal == "Signed Debug APK") and artifacts:
            apk_files = [f for f in artifacts if f.endswith('.apk')]
            if not apk_files:
                self.logger.log("Warning: No APK files found for {mode} mode", "WARNING", mode=mode_internal)
                # Попробуем найти AAB файлы и предупредить пользователя
                aab_files = [f for f in artifacts if f.endswith('.aab')]
                if aab_files:
                    self.logger.log("Found AAB files instead: {aab_files}", "WARNING", aab_files=", ".join(aab_files))
                    self.logger.log("This might indicate a configuration issue in the project", "WARNING")
                
                # Попробуем принудительно создать APK через Gradle
                self.logger.log("Attempting to force APK generation via Gradle...", "INFO")
                try:
                    self._force_apk_generation(cwd)
                    # Проверяем снова
                    artifacts = self._find_artifacts_cordova(cwd, mode_internal)
                    apk_files = [f for f in artifacts if f.endswith('.apk')]
                    if apk_files:
                        self.logger.log("Successfully generated APK via Gradle", "SUCCESS")
                    else:
                        self.logger.log("Failed to generate APK even via Gradle", "ERROR")
                except Exception as e:
                    self.logger.log("Failed to force APK generation: {error}", "ERROR", error=str(e))
        elif (mode_internal == "Unsigned AAB" or mode_internal == "Signed AAB") and artifacts:
            aab_files = [f for f in artifacts if f.endswith('.aab')]
            if not aab_files:
                self.logger.log("Warning: No AAB files found for {mode} mode", "WARNING", mode=mode_internal)
        # Подпись артефактов:
        # - Любой режим, начинающийся с "Signed"
        # - А ТАКЖЕ "Unsigned Release APK" (чтобы сделать APK устанавливаемым по умолчанию)
        if any(mode_internal.startswith(s) for s in ("Signed",)) or mode_internal == "Unsigned Release APK":
            # Если пользователь выбрал "Unsigned Release APK", но не настроил keystore — создаем автоматический
            if mode_internal == "Unsigned Release APK" and not self.keystore_info.get("path"):
                try:
                    self._create_auto_keystore(cwd)
                except Exception:
                    pass
            if not self.keystore_info.get("path"):
                raise Exception("Keystore not configured for signed build")
            self._sign_and_align(artifacts)
            self._set_progress(95, self._tr("Signing completed"))
        else:
            if artifacts:
                p = artifacts[0]
                try:
                    size = human_size(os.path.getsize(p))
                except Exception:
                    size = "?"
                self.logger.log("Artifact ready: {path} (size {size})", "SUCCESS", path=p, size=size)
                self._open_artifact_folder(p)
        self._set_progress(100, self._tr("Build completed successfully"))
        
        # Показываем окно поддержки после успешной сборки (неблокирующее)
        try:
            # Небольшая задержка, чтобы пользователь увидел результат
            self.after(2000, lambda: self._show_support_dialog())
        except Exception as e:
            self.logger.log("Failed to schedule support dialog: {error}", "WARNING", error=str(e))
    def _configure_gradle_for_apk(self, project_dir):
        """Настраивает Gradle для сборки APK вместо AAB"""
        try:
            self.logger.log("Configuring Gradle for APK generation...", "INFO")
            
            # Проверяем и модифицируем build.gradle в app модуле
            app_build_gradle = os.path.join(project_dir, "platforms", "android", "app", "build.gradle")
            if os.path.exists(app_build_gradle):
                with open(app_build_gradle, "r", encoding="utf-8", errors="ignore") as f:
                    content = f.read()
                
                modified = False
                
                # Отключаем bundle блок, если он есть
                if "bundle {" in content:
                    # Комментируем весь bundle блок
                    lines = content.split('\n')
                    new_lines = []
                    in_bundle_block = False
                    bundle_indent = 0
                    
                    for line in lines:
                        if "bundle {" in line:
                            in_bundle_block = True
                            bundle_indent = len(line) - len(line.lstrip())
                            new_lines.append("// " + line)
                        elif in_bundle_block:
                            current_indent = len(line) - len(line.lstrip())
                            if current_indent <= bundle_indent and line.strip() == "}":
                                in_bundle_block = False
                                new_lines.append("// " + line)
                            else:
                                new_lines.append("// " + line)
                        else:
                            new_lines.append(line)
                    
                    content = '\n'.join(new_lines)
                    modified = True
                    self.logger.log("Disabled bundle block in app build.gradle", "SUCCESS")
                
                # Добавляем принудительное создание APK
                if "android {" in content and "buildTypes {" in content:
                    # Добавляем конфигурацию для принудительного создания APK
                    apk_config = """
    // Force APK generation
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            debuggable true
        }
    }
"""
                    # Заменяем существующий buildTypes блок
                    if "buildTypes {" in content:
                        # Находим и заменяем buildTypes блок
                        start = content.find("buildTypes {")
                        if start != -1:
                            # Находим конец блока
                            brace_count = 0
                            end = start
                            for i in range(start, len(content)):
                                if content[i] == '{':
                                    brace_count += 1
                                elif content[i] == '}':
                                    brace_count -= 1
                                    if brace_count == 0:
                                        end = i + 1
                                        break
                            
                            # Заменяем блок
                            content = content[:start] + apk_config + content[end:]
                            modified = True
                            self.logger.log("Updated buildTypes configuration for APK", "SUCCESS")
                
                if modified:
                    with open(app_build_gradle, "w", encoding="utf-8") as f:
                        f.write(content)
                    self.logger.log("Successfully configured app build.gradle for APK", "SUCCESS")
                else:
                    self.logger.log("App build.gradle already configured for APK", "DEBUG")
                
                # Также проверяем и модифицируем build.gradle в корне проекта
                root_build_gradle = os.path.join(project_dir, "platforms", "android", "build.gradle")
                if os.path.exists(root_build_gradle):
                    with open(root_build_gradle, "r", encoding="utf-8", errors="ignore") as f:
                        root_content = f.read()
                    
                    # Убираем bundle plugin, если он есть
                    if "com.android.tools.build:gradle:" in root_content:
                        # Убеждаемся, что используется правильная версия плагина
                        if "bundle" in root_content:
                            root_content = root_content.replace("bundle", "apk")
                            with open(root_build_gradle, "w", encoding="utf-8") as f:
                                f.write(root_content)
                            self.logger.log("Updated root build.gradle to disable bundle plugin", "SUCCESS")
                        else:
                            self.logger.log("Root build.gradle already configured for APK", "DEBUG")
            else:
                self.logger.log("Warning: app build.gradle not found", "WARNING")
                
        except Exception as e:
            self.logger.log("Warning: Could not configure Gradle for APK: {warn}", "WARNING", warn=str(e))

    def _configure_gradle_for_aab(self, project_dir):
        """Настраивает Gradle для сборки AAB вместо APK"""
        try:
            # Проверяем и модифицируем build.gradle в app модуле
            app_build_gradle = os.path.join(project_dir, "platforms", "android", "app", "build.gradle")
            if os.path.exists(app_build_gradle):
                with open(app_build_gradle, "r", encoding="utf-8", errors="ignore") as f:
                    content = f.read()
                
                # Убираем комментарии с bundle блока, если они есть
                if "// bundle {" in content:
                    content = content.replace("// bundle {", "bundle {")
                    content = content.replace("// }", "}")
                    
                    with open(app_build_gradle, "w", encoding="utf-8") as f:
                        f.write(content)
                    self.logger.log("Modified build.gradle to enable bundle generation", "SUCCESS")
                else:
                    self.logger.log("build.gradle already configured for AAB", "DEBUG")
        except Exception as e:
            self.logger.log("Warning: Could not configure Gradle for AAB: {warn}", "WARNING", warn=str(e))

    def _force_apk_generation(self, project_dir):
        """Принудительно создает APK через Gradle"""
        try:
            self.logger.log("Forcing APK generation via Gradle...", "INFO")
            
            # Находим gradlew
            gradlew = "gradlew.bat" if platform.system() == "Windows" else "./gradlew"
            gradlew_path = os.path.join(project_dir, "platforms", "android", gradlew)
            
            if not os.path.exists(gradlew_path):
                gradlew_path = os.path.join(project_dir, gradlew)
            
            if not os.path.exists(gradlew_path):
                raise Exception("gradlew not found")
            
            # Сначала очищаем предыдущую сборку
            clean_cmd = [gradlew_path, "clean"]
            self.logger.log("Cleaning previous build...", "INFO")
            clean_rc = self._run_and_stream(clean_cmd, cwd=os.path.join(project_dir, "platforms", "android"))
            if clean_rc != 0:
                self.logger.log("Warning: Gradle clean failed, continuing anyway", "WARNING")
            
            # Принудительно создаем APK вместо AAB
            # Запускаем assembleRelease для создания APK
            cmd = [gradlew_path, "assembleRelease"]
            self.logger.log("Running Gradle command: {cmd}", "INFO", cmd=" ".join(cmd))
            
            # Запускаем assembleRelease
            rc = self._run_and_stream(cmd, cwd=os.path.join(project_dir, "platforms", "android"))
            if rc != 0:
                # Если assembleRelease не сработал, пробуем assembleDebug
                self.logger.log("assembleRelease failed, trying assembleDebug...", "WARNING")
                cmd = [gradlew_path, "assembleDebug"]
                rc = self._run_and_stream(cmd, cwd=os.path.join(project_dir, "platforms", "android"))
                if rc != 0:
                    raise Exception(f"Gradle assembleDebug failed with code {rc}")
            
            self.logger.log("Gradle APK generation completed successfully", "SUCCESS")
            
        except Exception as e:
            self.logger.log("Error in force APK generation: {error}", "ERROR", error=str(e))
            raise

    def _apply_cordova_patches(self, project_dir):
        try:
            cordova_gradle = os.path.join(project_dir, "platforms", "android", "CordovaLib", "cordova.gradle")
            if os.path.exists(cordova_gradle):
                with open(cordova_gradle, "r", encoding="utf-8", errors="ignore") as f:
                    content = f.read()
                if "import groovy.xml.XmlParser" not in content:
                    new = "import groovy.xml.XmlParser\n" + content
                    with open(cordova_gradle, "w", encoding="utf-8") as f:
                        f.write(new)
                    self.logger.log("Added import groovy.xml.XmlParser to cordova.gradle", "SUCCESS")
                else:
                    self.logger.log("cordova.gradle already patched", "DEBUG")
            else:
                self.logger.log("cordova.gradle not found, skipping patch", "DEBUG")
        except Exception as e:
            self.logger.log("Warning: {warn}", "WARNING", warn=str(e))
    def _find_artifacts_cordova(self, project_dir, mode_internal=None):
        out = []
        base = os.path.join(project_dir, "platforms", "android")
        if not os.path.exists(base):
            base = project_dir
        
        self.logger.log("Searching for artifacts in: {base}", "DEBUG", base=base)
        
        # Определяем, какие файлы искать в зависимости от режима
        if mode_internal == "Unsigned Release APK" or mode_internal == "Signed Release APK" or mode_internal == "Debug APK" or mode_internal == "Signed Debug APK":
            # Для APK (подписанных и неподписанных, release и debug) ищем только APK файлы
            extensions = [".apk"]
            self.logger.log("Searching for APK files only in mode: {mode}", "DEBUG", mode=mode_internal)
        elif mode_internal == "Unsigned AAB" or mode_internal == "Signed AAB":
            # Для AAB (подписанных и неподписанных) ищем только AAB файлы
            extensions = [".aab"]
            self.logger.log("Searching for AAB files only in mode: {mode}", "DEBUG", mode=mode_internal)
        else:
            # Для остальных режимов ищем оба типа
            extensions = [".apk", ".aab"]
            self.logger.log("Searching for both APK and AAB files", "DEBUG")
        
        for root, _, files in os.walk(base):
            for f in files:
                if any(f.endswith(ext) for ext in extensions):
                    out.append(os.path.join(root, f))
        
        # Сортируем результаты: сначала APK, потом AAB
        out.sort(key=lambda x: (not x.endswith('.apk'), x))
        
        # Дополнительная проверка: если для APK не найдено ни одного файла, попробуем найти в других местах
        if (mode_internal == "Unsigned Release APK" or mode_internal == "Signed Release APK" or mode_internal == "Debug APK" or mode_internal == "Signed Debug APK") and not out:
            self.logger.log("No APK files found in standard location, searching more broadly...", "WARNING")
            # Ищем в других возможных местах
            additional_paths = [
                os.path.join(project_dir, "platforms", "android", "app", "build", "outputs", "apk", "release"),
                os.path.join(project_dir, "platforms", "android", "app", "build", "outputs", "apk", "debug"),
                os.path.join(project_dir, "platforms", "android", "app", "build", "outputs", "bundle", "release"),
                os.path.join(project_dir, "build", "outputs", "apk", "release"),
                os.path.join(project_dir, "build", "outputs", "apk", "debug"),
                os.path.join(project_dir, "build", "outputs", "bundle", "release"),
                # Добавляем поиск в промежуточных папках
                os.path.join(project_dir, "platforms", "android", "app", "build", "intermediates", "apk", "release"),
                os.path.join(project_dir, "platforms", "android", "app", "build", "intermediates", "apk", "debug"),
                os.path.join(project_dir, "platforms", "android", "app", "build", "intermediates", "bundle", "release"),
                # Поиск в корне проекта
                os.path.join(project_dir, "platforms", "android", "app", "build", "outputs"),
                os.path.join(project_dir, "platforms", "android", "app", "build"),
                # Поиск в корне проекта для Cordova
                os.path.join(project_dir, "platforms", "android", "build", "outputs", "apk", "release"),
                os.path.join(project_dir, "platforms", "android", "build", "outputs", "apk", "debug"),
                os.path.join(project_dir, "platforms", "android", "build", "outputs", "bundle", "release"),
                # Поиск в папке platforms/android
                os.path.join(project_dir, "platforms", "android"),
                # Поиск в корне проекта
                project_dir
            ]
            
            for path in additional_paths:
                if os.path.exists(path):
                    for root, _, files in os.walk(path):
                        for f in files:
                            if f.endswith(".apk"):
                                out.append(os.path.join(root, f))
                                self.logger.log(f"Found APK in additional location: {os.path.join(root, f)}", "INFO")
        
        # Логируем найденные файлы
        if out:
            self.logger.log("Found artifacts: {artifacts}", "DEBUG", artifacts=", ".join(out))
        else:
            self.logger.log("No artifacts found", "DEBUG")
        
        return out
    def _build_android_studio(self, mode_internal):
        self._set_progress(10, self._tr("Starting Android Studio build..."))
        gradlew = "gradlew.bat" if platform.system() == "Windows" else "./gradlew"
        cwd = self.project_path
        gradlew_path = os.path.join(cwd, gradlew)
        if not os.path.exists(gradlew_path):
            raise Exception("gradlew not found in project root")

        # Автоматически создаем build.json перед сборкой
        self._set_progress(15, self._tr("Creating build configuration..."))
        build_json_path = self._create_build_json(cwd, mode_internal)
        if build_json_path:
            self.logger.log("build.json created and integrated into project", "SUCCESS")
        else:
            self.logger.log("Warning: Could not create build.json, continuing with manual signing", "WARNING")
        
        # Определяем правильную команду в зависимости от режима
        if mode_internal == "Debug APK":
            cmd = [gradlew, "assembleDebug"]
            self.logger.log("Building Debug APK...", "INFO")
        elif mode_internal == "Signed Debug APK":
            cmd = [gradlew, "assembleDebug"]
            self.logger.log("Building Signed Debug APK...", "INFO")
        elif mode_internal == "Unsigned Release APK":
            cmd = [gradlew, "assembleRelease"]
            self.logger.log("Building Unsigned Release APK...", "INFO")
        elif mode_internal == "Signed Release APK":
            cmd = [gradlew, "assembleRelease"]
            self.logger.log("Building Signed Release APK...", "INFO")
        elif mode_internal == "Unsigned AAB":
            cmd = [gradlew, "bundleRelease"]
            self.logger.log("Building Unsigned AAB...", "INFO")
        elif mode_internal == "Signed AAB":
            cmd = [gradlew, "bundleRelease"]
            self.logger.log("Building Signed AAB...", "INFO")
        else:
            # По умолчанию создаем APK
            cmd = [gradlew, "assembleRelease"]
            self.logger.log("Building default APK...", "INFO")
        
        # Настраиваем Gradle для правильного типа сборки
        if "APK" in mode_internal:
            self.logger.log("Configuring Gradle for APK generation...", "INFO")
            self._configure_gradle_for_apk(cwd)
        elif "AAB" in mode_internal:
            self.logger.log("Configuring Gradle for AAB generation...", "INFO")
            self._configure_gradle_for_aab(cwd)
        
        self.logger.log("Running gradle command: {cmd}", "INFO", cmd=" ".join(cmd))
        self._set_progress(20, self._tr("Build: {mode_internal}...", mode_internal=mode_internal))
        rc = self._run_and_stream(cmd, cwd=cwd)
        self._set_progress(70, self._tr("Build completed"))
        if rc != 0:
            raise Exception(f"Gradle build failed with code {rc}")
        
        # Ищем артефакты после сборки
        self.logger.log("Searching for build artifacts...", "INFO")
        artifacts = self._find_artifacts(cwd, mode_internal)
        self.logger.log("Found build artifacts: {paths}", "INFO", paths=", ".join(artifacts) if artifacts else "(none)")
        
        # Проверяем, что создались правильные типы файлов
        if "APK" in mode_internal:
            apk_files = [f for f in artifacts if f.endswith('.apk')]
            if not apk_files:
                self.logger.log("Warning: No APK files found for APK mode, checking for AAB files...", "WARNING")
                aab_files = [f for f in artifacts if f.endswith('.aab')]
                if aab_files:
                    self.logger.log("Found AAB files instead of APK. This indicates Gradle configuration issue.", "ERROR")
                    self.logger.log("AAB files found: {files}", "ERROR", files=", ".join(aab_files))
                    raise Exception("Gradle created AAB instead of APK. Please check build configuration.")
        elif "AAB" in mode_internal:
            aab_files = [f for f in artifacts if f.endswith('.aab')]
            if not aab_files:
                self.logger.log("Warning: No AAB files found for AAB mode", "WARNING")
        self._set_progress(80, self._tr("Artifacts found"))
        # Подпись артефактов:
        # - Любой режим, начинающийся с "Signed"
        # - А ТАКЖЕ "Unsigned Release APK" (чтобы сделать APK устанавливаемым по умолчанию)
        if any(mode_internal.startswith(s) for s in ("Signed",)) or mode_internal == "Unsigned Release APK":
            # Если пользователь выбрал "Unsigned Release APK", но не настроил keystore — создаем автоматический
            if mode_internal == "Unsigned Release APK" and not self.keystore_info.get("path"):
                try:
                    self._create_auto_keystore(cwd)
                except Exception:
                    pass
            if not self.keystore_info.get("path"):
                raise Exception("Keystore not configured for signed build")
            if not artifacts:
                raise Exception("No artifacts found to sign")
            
            # Фильтруем артефакты в зависимости от режима
            filtered_artifacts = []
            if "APK" in mode_internal:
                # Для APK режимов подписываем только APK файлы
                filtered_artifacts = [art for art in artifacts if art.endswith('.apk')]
                self.logger.log("APK mode: filtering to APK files only", "INFO")
            elif "AAB" in mode_internal:
                # Для AAB режимов подписываем только AAB файлы
                filtered_artifacts = [art for art in artifacts if art.endswith('.aab')]
                self.logger.log("AAB mode: filtering to AAB files only", "INFO")
            else:
                # Для остальных режимов используем все артефакты
                filtered_artifacts = artifacts
            
            if not filtered_artifacts:
                raise Exception(f"No {mode_internal.split()[-1]} files found to sign")
            
            self.logger.log("Starting signing process for {count} artifacts", "INFO", count=len(filtered_artifacts))
            self._sign_and_align(filtered_artifacts)
            self._set_progress(95, self._tr("Signing completed"))
        else:
            if artifacts:
                p = artifacts[0]
                try:
                    size = human_size(os.path.getsize(p))
                except Exception:
                    size = "?"
                self.logger.log("Artifact ready: {path} (size {size})", "SUCCESS", path=p, size=size)
                self._open_artifact_folder(p)
        self._set_progress(100, self._tr("Build completed successfully"))
        
        # Показываем окно поддержки после успешной сборки (неблокирующее)
        try:
            # Небольшая задержка, чтобы пользователь увидел результат
            self.after(2000, lambda: self._show_support_dialog())
        except Exception as e:
            self.logger.log("Failed to schedule support dialog: {error}", "WARNING", error=str(e))
    def _sign_and_align(self, artifacts):
        # Фильтруем артефакты, чтобы не подписывать уже подписанные файлы
        files_to_sign = []
        for art in artifacts:
            # Пропускаем уже подписанные файлы
            if "-unsigned" in art or "intermediary-bundle" in art:
                files_to_sign.append(art)
            elif not any(skip in art for skip in ["-signed", ".signed", "_signed"]):
                # Если файл не содержит признаков подписи, добавляем его
                files_to_sign.append(art)
        
        self.logger.log("Files to sign: {files}", "DEBUG", files=", ".join(files_to_sign))
        
        signed_files = []
        for art in files_to_sign:
            if art.endswith(".apk"):
                result = self._sign_apk(art)
                if result:
                    signed_files.append(result)
            elif art.endswith(".aab"):
                result = self._sign_aab(art)
                if result:
                    signed_files.append(result)
        
        # Открываем папку только один раз для всех подписанных файлов
        if signed_files:
            self._open_artifact_folder(signed_files[0])
    def _sign_apk(self, apk):
        try:
            self.logger.log("Signing APK: {path}", "INFO", path=apk)
            basename = os.path.basename(apk)
            self._set_progress(self.current_progress, self._tr("Signing APK: {basename}...", basename=basename))
            
            # Проверяем, есть ли build.json в проекте
            project_dir = os.path.dirname(os.path.dirname(os.path.dirname(apk)))  # Поднимаемся до корня проекта
            build_json_path = os.path.join(project_dir, "build.json")
            
            # Если build.json существует и содержит информацию о keystore, используем его
            if os.path.exists(build_json_path):
                try:
                    import json
                    with open(build_json_path, 'r', encoding='utf-8') as f:
                        build_config = json.load(f)
                    
                    # Определяем, какую секцию использовать (debug или release)
                    # Для APK файлов определяем по пути - если в пути есть "debug", используем debug секцию
                    android_config = {}
                    if "debug" in apk.lower() or "debug" in os.path.dirname(apk).lower():
                        android_config = build_config.get("android", {}).get("debug", {})
                        self.logger.log("Using debug keystore configuration from build.json", "INFO")
                    else:
                        android_config = build_config.get("android", {}).get("release", {})
                        self.logger.log("Using release keystore configuration from build.json", "INFO")
                    
                    if android_config.get("keystore"):
                        ks = {
                            "path": android_config["keystore"],
                            "storepass": android_config.get("storePassword", ""),
                            "alias": android_config.get("alias", ""),
                            "keypass": android_config.get("password", android_config.get("storePassword", ""))
                        }
                    else:
                        ks = self.keystore_info
                except Exception as e:
                    self.logger.log("Warning: Could not read build.json, using manual keystore info: {error}", "WARNING", error=str(e))
                    ks = self.keystore_info
            else:
                ks = self.keystore_info
            
            buildtools = os.path.join(self.DEP_DIR, "android-sdk", "build-tools", "33.0.2")
            zipalign = os.path.join(buildtools, "zipalign.exe" if platform.system() == "Windows" else "zipalign")
            apksigner = os.path.join(buildtools, "apksigner.bat" if platform.system() == "Windows" else "apksigner")
            src = apk
            
            # Выравнивание APK
            if os.path.exists(zipalign):
                # Создаем временное имя для выровненного файла
                aligned = apk.replace(".apk", ".aligned.apk")
                rc = self._run_and_stream([zipalign, "-p", "4", src, aligned])
                if rc == 0:
                    src = aligned
                    self.logger.log("APK aligned successfully: {aligned}", "SUCCESS", aligned=aligned)
                else:
                    self.logger.log("Warning: zipalign failed; continuing with original apk", "WARNING")
            else:
                self.logger.log("Warning: zipalign not found", "WARNING")
            
            if not os.path.exists(apksigner):
                self.logger.log("Error: apksigner not found", "ERROR")
                return None
                
            if not os.path.exists(ks["path"]):
                self.logger.log("Error: Keystore file not found: {path}", "ERROR", path=ks["path"])
                return None
            
            # Подпись APK
            cmd = [
                apksigner, "sign",
                "--ks", ks["path"],
                "--ks-pass", f"pass:{ks['storepass']}",
                "--ks-key-alias", ks["alias"],
                "--key-pass", f"pass:{ks['keypass']}",
                src
            ]
            
            self.logger.log("Signing APK with apksigner...", "INFO")
            rc = self._run_and_stream(cmd)
            
            if rc == 0:
                # Переименовываем подписанный файл в правильное имя
                final_name = apk.replace("-unsigned", "").replace(".aligned", "")
                if src != apk:  # Если использовался выровненный файл
                    try:
                        if os.path.exists(final_name):
                            os.remove(final_name)  # Удаляем старый файл если существует
                        os.rename(src, final_name)
                        src = final_name
                        self.logger.log("Renamed signed APK to: {final_name}", "SUCCESS", final_name=final_name)
                    except Exception as e:
                        self.logger.log("Warning: Failed to rename signed APK: {error}", "WARNING", error=str(e))
                
                self.logger.log("APK signed successfully: {path}", "SUCCESS", path=src)
                
                # Очищаем временные файлы
                if 'aligned' in locals() and os.path.exists(aligned) and aligned != src:
                    try:
                        os.remove(aligned)
                        self.logger.log("Cleaned up temporary aligned file: {aligned}", "DEBUG", aligned=aligned)
                    except Exception as e:
                        self.logger.log("Warning: Failed to clean up temporary file: {error}", "WARNING", error=str(e))
                
                return src  # Возвращаем путь к подписанному файлу
            else:
                self.logger.log("Error: apksigner returned code {rc}", "ERROR", rc=rc)
                return None
                
        except Exception as e:
            self.logger.log("Error signing APK: {error}", "ERROR", error=str(e))
            self.logger.raw(traceback.format_exc())
            return None
    def _sign_aab(self, aab):
        try:
            self.logger.log("Signing AAB: {path}", "INFO", path=aab)
            basename = os.path.basename(aab)
            self._set_progress(self.current_progress, self._tr("Signing AAB: {basename}...", basename=basename))
            
            # Проверяем, есть ли build.json в проекте
            project_dir = os.path.dirname(os.path.dirname(os.path.dirname(aab)))  # Поднимаемся до корня проекта
            build_json_path = os.path.join(project_dir, "build.json")
            
            # Если build.json существует и содержит информацию о keystore, используем его
            if os.path.exists(build_json_path):
                try:
                    import json
                    with open(build_json_path, 'r', encoding='utf-8') as f:
                        build_config = json.load(f)
                    
                    # Для AAB файлов всегда используем release секцию
                    android_config = build_config.get("android", {}).get("release", {})
                    if android_config.get("keystore"):
                        self.logger.log("Using release keystore configuration from build.json for AAB", "INFO")
                        ks = {
                            "path": android_config["keystore"],
                            "storepass": android_config.get("storePassword", ""),
                            "alias": android_config.get("alias", ""),
                            "keypass": android_config.get("password", android_config.get("storePassword", ""))
                        }
                    else:
                        ks = self.keystore_info
                except Exception as e:
                    self.logger.log("Warning: Could not read build.json, using manual keystore info: {error}", "WARNING", error=str(e))
                    ks = self.keystore_info
            else:
                ks = self.keystore_info
            
            jarsigner = os.path.join(self.DEP_DIR, "jdk", "bin", "jarsigner.exe" if platform.system() == "Windows" else "jarsigner")
            if not os.path.exists(jarsigner):
                self.logger.log("Error: jarsigner not found", "ERROR")
                return None
                
            if not os.path.exists(ks["path"]):
                self.logger.log("Error: Keystore file not found: {path}", "ERROR", path=ks["path"])
                return None
            
            # Подпись AAB с использованием jarsigner
            cmd = [
                jarsigner, "-verbose",
                "-keystore", ks["path"],
                "-storepass", ks["storepass"],
                "-keypass", ks["keypass"],
                aab, ks["alias"]
            ]
            
            self.logger.log("Signing AAB with jarsigner...", "INFO")
            rc = self._run_and_stream(cmd)
            
            if rc == 0:
                self.logger.log("AAB signed successfully: {path}", "SUCCESS", path=aab)
                return aab  # Возвращаем путь к подписанному файлу
            else:
                self.logger.log("Error: jarsigner returned code {rc}", "ERROR", rc=rc)
                return None
                
        except Exception as e:
            self.logger.log("Error signing AAB: {error}", "ERROR", error=str(e))
            self.logger.raw(traceback.format_exc())
            return None

    def _create_build_json(self, project_dir, mode_internal):
        """Создает build.json файл автоматически в корне проекта"""
        try:
            self.logger.log("Creating build.json configuration file...", "INFO")
            
            # Определяем путь к build.json в корне проекта
            build_json_path = os.path.join(project_dir, "build.json")
            
            # Создаем конфигурацию для build.json
            build_config = {
                "android": {
                    "debug": {},
                    "release": {}
                }
            }
            
            # Если это подписанная сборка, добавляем информацию о keystore
            if mode_internal.startswith("Signed"):
                if not self.keystore_info.get("path"):
                    # Создаем keystore автоматически если не существует
                    self._create_auto_keystore(project_dir)
                
                ks = self.keystore_info
                if ks.get("path"):
                    # Конвертируем путь в формат с прямыми слешами для Windows
                    keystore_path = ks["path"].replace("\\", "/")
                    
                    keystore_config = {
                        "keystore": keystore_path,
                        "storePassword": ks.get("storepass", ""),
                        "alias": ks.get("alias", ""),
                        "password": ks.get("keypass", ks.get("storepass", "")),
                        "keystoreType": ""  # Оставляем пустым для JKS
                    }
                    
                    # Добавляем конфигурацию keystore в нужную секцию
                    if "Debug" in mode_internal:
                        build_config["android"]["debug"] = keystore_config
                        self.logger.log("Added keystore configuration to debug section in build.json", "SUCCESS")
                    else:
                        build_config["android"]["release"] = keystore_config
                        self.logger.log("Added keystore configuration to release section in build.json", "SUCCESS")
                    
                    self.logger.log("Keystore path: {path}", "DEBUG", path=keystore_path)
                    self.logger.log("Alias: {alias}", "DEBUG", alias=ks.get("alias", ""))
                else:
                    self.logger.log("Warning: No keystore information available for signed build", "WARNING")
            
            # Записываем build.json файл
            import json
            with open(build_json_path, 'w', encoding='utf-8') as f:
                json.dump(build_config, f, indent=2, ensure_ascii=False)
            
            # Проверяем, что файл действительно создался
            if os.path.exists(build_json_path):
                self.logger.log("build.json created successfully: {path}", "SUCCESS", path=build_json_path)
                # Логируем содержимое для отладки
                self.logger.log("build.json content: {content}", "DEBUG", content=json.dumps(build_config, indent=2))
                
                # Дополнительно создаем файл в папке platforms/android (на случай если Cordova ищет там)
                android_build_json = os.path.join(project_dir, "platforms", "android", "build.json")
                try:
                    safe_makedirs(os.path.dirname(android_build_json))
                    with open(android_build_json, 'w', encoding='utf-8') as f:
                        json.dump(build_config, f, indent=2, ensure_ascii=False)
                    self.logger.log("Also created build.json in platforms/android: {path}", "DEBUG", path=android_build_json)
                except Exception as e:
                    self.logger.log("Warning: Could not create build.json in platforms/android: {error}", "WARNING", error=str(e))
                
                return build_json_path
            else:
                self.logger.log("Error: build.json file was not created", "ERROR")
                return None
            
        except Exception as e:
            self.logger.log("Error creating build.json: {error}", "ERROR", error=str(e))
            return None

    def _create_auto_keystore(self, project_dir):
        """Автоматически создает keystore если не существует"""
        try:
            self.logger.log("Creating automatic keystore...", "INFO")
            
            # Создаем папку для keystore в проекте
            keystore_dir = os.path.join(project_dir, "keystore")
            safe_makedirs(keystore_dir)
            
            # Генерируем имя keystore файла
            keystore_name = "release-key.keystore"
            keystore_path = os.path.join(keystore_dir, keystore_name)
            
            # Проверяем, не существует ли уже keystore
            if os.path.exists(keystore_path):
                self.logger.log("Keystore already exists: {path}", "INFO", path=keystore_path)
                # Загружаем существующий keystore
                self.ks_path_var.set(keystore_path)
                self.alias_var.set("my_app_alias")
                self.ks_pass_var.set("android")
                self.key_pass_var.set("android")
                self._update_keystore_info()
                return keystore_path
            
            # Создаем новый keystore с автоматическими параметрами
            keytool = os.path.join(self.DEP_DIR, "jdk", "bin", "keytool.exe" if platform.system() == "Windows" else "keytool")
            
            # Автоматические параметры для keystore
            alias = "my_app_alias"
            storepass = "android"
            keypass = "android"
            validity_days = 10000  # ~27 лет
            
            # DName для keystore
            dname = "CN=Android Debug, OU=Android, O=Google Inc., L=Mountain View, ST=California, C=US"
            
            cmd = [
                keytool, "-genkey", "-v", "-keystore", keystore_path,
                "-keyalg", "RSA", "-keysize", "2048",
                "-validity", str(validity_days), "-alias", alias,
                "-dname", dname,
                "-storepass", storepass, "-keypass", keypass
            ]
            
            self.logger.log("Generating keystore with command: {cmd}", "DEBUG", cmd=" ".join(cmd))
            rc = self._run_and_stream(cmd)
            
            if rc == 0:
                # Обновляем информацию о keystore в интерфейсе
                self.ks_path_var.set(keystore_path)
                self.alias_var.set(alias)
                self.ks_pass_var.set(storepass)
                self.key_pass_var.set(keypass)
                self._update_keystore_info()
                
                self.logger.log("Automatic keystore created successfully: {path}", "SUCCESS", path=keystore_path)
                self.logger.log("Keystore details:", "INFO")
                self.logger.log("  Alias: {alias}", "INFO", alias=alias)
                self.logger.log("  Store Password: {password}", "INFO", password=storepass)
                self.logger.log("  Key Password: {password}", "INFO", password=keypass)
                self.logger.log("  Validity: {days} days", "INFO", days=validity_days)
                
                return keystore_path
            else:
                self.logger.log("Failed to create automatic keystore", "ERROR")
                return None
                
        except Exception as e:
            self.logger.log("Error creating automatic keystore: {error}", "ERROR", error=str(e))
            return None

    def _verify_keystore(self, keystore_path, alias, storepass):
        """Проверяет валидность keystore файла"""
        try:
            keytool = os.path.join(self.DEP_DIR, "jdk", "bin", "keytool.exe" if platform.system() == "Windows" else "keytool")
            cmd = [
                keytool, "-list", "-v",
                "-keystore", keystore_path,
                "-alias", alias,
                "-storepass", storepass
            ]
            
            rc = self._run_and_capture(cmd)
            if rc and "Alias name:" in rc:
                self.logger.log("Keystore verification successful", "SUCCESS")
                return True
            else:
                self.logger.log("Keystore verification failed", "ERROR")
                return False
                
        except Exception as e:
            self.logger.log("Error verifying keystore: {error}", "ERROR", error=str(e))
            return False

    def _backup_keystore(self, keystore_path):
        """Создает резервную копию keystore файла"""
        try:
            if os.path.exists(keystore_path):
                backup_path = keystore_path + ".backup"
                shutil.copy2(keystore_path, backup_path)
                self.logger.log("Keystore backup created: {backup}", "SUCCESS", backup=backup_path)
                return backup_path
        except Exception as e:
            self.logger.log("Warning: Could not create keystore backup: {error}", "WARNING", error=str(e))
        return None
    def _open_artifact_folder(self, path):
        try:
            folder = os.path.dirname(path)
            if platform.system() == "Windows":
                os.startfile(folder)
            elif platform.system() == "Darwin":
                subprocess.Popen(["open", folder], startupinfo=get_hidden_startupinfo())
            else:
                subprocess.Popen(["xdg-open", folder], startupinfo=get_hidden_startupinfo())
            self.logger.log("Opening folder: {folder}", "INFO", folder=folder)
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
    def _open_dependencies(self):
        self._open_artifact_folder(self.DEP_DIR)
    def _open_logs_dir(self):
        self._open_artifact_folder(self.LOGS_DIR)

    def _delete_project_folders(self):
        """Удаляет все папки проектов"""
        try:
            result = messagebox.askyesno(
                self._tr("Confirm Delete"), 
                self._tr("This will delete all project folders. Continue?")
            )
            if not result:
                return
                
            if os.path.exists(self.PROJ_DIR):
                shutil.rmtree(self.PROJ_DIR)
                safe_makedirs(self.PROJ_DIR)
                self.logger.log("Deleted all project folders: {path}", "SUCCESS", path=self.PROJ_DIR)
                self.project_loaded = False
                self.project_info_var.set(self._tr("No project loaded"))
                self.btn_build.configure(state="disabled")
            else:
                self.logger.log("No project folders to delete", "INFO")
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())

    def _diagnose_splash(self):
        """Проверка применимости иконок и сплэш-скрина для текущего проекта."""
        try:
            proj = getattr(self, 'project_path', None)
            if not proj or not os.path.exists(proj):
                self.logger.log("Error: {err}", "ERROR", err="Project not loaded")
                return
            self.logger.log("Diagnostics for project: {path}", "INFO", path=proj)
            # Check files presence
            to_check = [
                os.path.join(proj, 'www', 'icons', 'icon-128.png'),
                os.path.join(proj, 'www', 'icons', 'icon-129.png'),
                os.path.join(proj, 'resources', 'icon.png'),
                os.path.join(proj, 'resources', 'splash.png'),
                os.path.join(proj, 'icon.png'),
                os.path.join(proj, 'splash_128.png'),
            ]
            for p in to_check:
                self.logger.log(("Found: {name}" if os.path.exists(p) else "Missing: {name}"), "INFO" if os.path.exists(p) else "WARNING", name=p)
            # Inspect config.xml
            cfg_xml = os.path.join(proj, 'config.xml')
            if os.path.exists(cfg_xml):
                try:
                    import xml.etree.ElementTree as ET
                    tree = ET.parse(cfg_xml)
                    root = tree.getroot()
                    # log preferences
                    for pref in root.findall('preference'):
                        n = pref.get('name')
                        if n and ("Splash" in n or "AndroidWindowSplash" in n):
                            self.logger.log("config.xml preference: {name}={value}", "DEBUG", name=n, value=pref.get('value'))
                    # android platform
                    for p in root.findall('platform'):
                        if p.get('name') == 'android':
                            for ic in p.findall('icon'):
                                self.logger.log("android icon: {src}", "DEBUG", src=ic.get('src'))
                            for sp in p.findall('splash'):
                                self.logger.log("android splash: {src}", "DEBUG", src=sp.get('src'))
                except Exception as e:
                    self.logger.log("Error: {err}", "ERROR", err=f"Failed to parse config.xml: {e}")
            else:
                self.logger.log("Warning: {warn}", "WARNING", warn="config.xml not found")
            # Inspect generated platform res
            plat_res = os.path.join(proj, 'platforms', 'android', 'app', 'src', 'main', 'res')
            if os.path.exists(plat_res):
                # look for splash drawables and mipmap icons
                hits = []
                for root_dir, _, files in os.walk(plat_res):
                    for f in files:
                        if f.lower().startswith(('splash', 'launch_background')) or f.lower().startswith(('ic_launcher', 'icon')):
                            hits.append(os.path.join(root_dir, f))
                if hits:
                    self.logger.log("Generated res files:", "INFO")
                    for h in hits[:50]:
                        self.logger.log("  {path}", "DEBUG", path=h)
                else:
                    self.logger.log("Warning: {warn}", "WARNING", warn="No generated res files found under platforms/android/app/src/main/res")
            else:
                self.logger.log("Warning: {warn}", "WARNING", warn="Android platform res folder not found; rebuild will recreate")
        except Exception as e:
            self.logger.log("Error: {err}", "ERROR", err=str(e))
            self.logger.raw(traceback.format_exc())

    def _sanitize_config_xml(self, proj):
        """Автоматически исправляет config.xml для корректной Cordova-сборки.
        Делает следующее:
        - Меняет xmlns:ns0 -> xmlns:android и ns0:name -> android:name
        - Удаляет устаревшие <splash/> теги
        - Обновляет <engine name="android" spec="12.0.0"/>
        - Гарантирует наличие prefs AndroidWindowSplashScreen* и корректных uses-permission с android:name
        """
        try:
            cfg_xml = os.path.join(proj, 'config.xml')
            if not os.path.exists(cfg_xml):
                # Создаем минимальный корректный config.xml, если он отсутствует
                try:
                    app_id = "com.example.app"
                    app_name = os.path.basename(proj) or "CordovaApp"
                    version = "1.0.0"
                    minimal = (
                        "<?xml version='1.0' encoding='utf-8'?>\n"
                        f"<widget xmlns:android=\"http://schemas.android.com/apk/res/android\" id=\"{app_id}\" version=\"{version}\" android-versionCode=\"1000000\">\n"
                        f"\t<name>{app_name}</name>\n"
                        "\t<content src=\"index.html\" />\n"
                        "\t<access origin=\"*\" />\n"
                        "\t<allow-intent href=\"http://*/*\" />\n"
                        "\t<allow-intent href=\"https://*/*\" />\n"
                        "\t<allow-navigation href=\"*\" />\n"
                        "\t<preference name=\"AndroidWindowSplashScreenAnimatedIcon\" value=\"www/icons/icon-128.png\" />\n"
                        "\t<preference name=\"AndroidWindowSplashScreenBackground\" value=\"#ffffff\" />\n"
                        "\t<engine name=\"android\" spec=\"12.0.0\" />\n"
                        "\t<platform name=\"android\">\n"
                        "\t\t<preference name=\"android-minSdkVersion\" value=\"24\" />\n"
                        "\t\t<preference name=\"android-targetSdkVersion\" value=\"34\" />\n"
                        "\t\t<config-file target=\"AndroidManifest.xml\" parent=\"/manifest\">\n"
                        "\t\t\t<uses-permission android:name=\"android.permission.INTERNET\" />\n"
                        "\t\t</config-file>\n"
                        "\t</platform>\n"
                        "</widget>\n"
                    )
                    with open(cfg_xml, 'w', encoding='utf-8') as f:
                        f.write(minimal)
                    self.logger.log("Created minimal config.xml as it was missing", "WARNING")
                except Exception:
                    return
            # Сначала быстрые текстовые исправления namespace
            try:
                with open(cfg_xml, 'r', encoding='utf-8', errors='ignore') as f:
                    txt = f.read()
                changed = False
                if 'xmlns:ns0=' in txt:
                    txt = txt.replace('xmlns:ns0=', 'xmlns:android=')
                    changed = True
                if 'ns0:name=' in txt:
                    txt = txt.replace('ns0:name=', 'android:name=')
                    changed = True
                # Нормализуем engine spec на 12.0.0
                if '<engine name="android"' in txt:
                    # простая замена spec="..." на 12.0.0
                    import re
                    txt_new = re.sub(r'(<engine\s+name="android"[^>]*spec=")[^"]+(")', r'\112.0.0\2', txt)
                    if txt_new != txt:
                        txt = txt_new
                        changed = True
                else:
                    # Добавим engine в корень виджета (позже через XML вставим корректно)
                    pass
                if changed:
                    with open(cfg_xml, 'w', encoding='utf-8') as f:
                        f.write(txt)
            except Exception:
                pass

            # Теперь работаем как с XML
            import xml.etree.ElementTree as ET
            try:
                tree = ET.parse(cfg_xml)
                root = tree.getroot()
            except Exception:
                return

            # Удаляем все <splash> из корня и из android-платформы
            for sp in list(root.findall('splash')):
                root.remove(sp)
            for plat in root.findall('platform'):
                if plat.get('name') == 'android':
                    for sp in list(plat.findall('splash')):
                        plat.remove(sp)

            # Гарантируем наличие нужных preferences
            def set_pref(name, value):
                for p in root.findall('preference'):
                    if p.get('name') == name:
                        if value is not None:
                            p.set('value', value)
                        return p
                p = ET.SubElement(root, 'preference')
                p.set('name', name)
                if value is not None:
                    p.set('value', value)
                return p

            set_pref('AndroidWindowSplashScreenAnimatedIcon', 'www/icons/icon-128.png')
            set_pref('AndroidWindowSplashScreenBackground', '#ffffff')

            # Обеспечим корректный блок <platform name="android"> и uses-permission
            android_plat = None
            for p in root.findall('platform'):
                if p.get('name') == 'android':
                    android_plat = p
                    break
            if android_plat is None:
                android_plat = ET.SubElement(root, 'platform')
                android_plat.set('name', 'android')

            # Пройдёмся по config-file/uses-permission и поправим android:name атрибут
            for cfg in android_plat.findall('config-file'):
                for up in cfg.findall('uses-permission'):
                    nm = up.get('android:name') or up.get('ns0:name') or up.get('name')
                    if nm:
                        # Сбрасываем некорректные атрибуты и выставляем верный
                        for k in list(up.keys()):
                            if k != 'android:name':
                                up.attrib.pop(k, None)
                        up.set('android:name', nm)

            # Обновим/вставим тег engine android со spec=12.0.0
            has_engine = False
            for eng in root.findall('engine'):
                if eng.get('name') == 'android':
                    eng.set('spec', '12.0.0')
                    has_engine = True
            if not has_engine:
                ET.SubElement(root, 'engine', {'name': 'android', 'spec': '12.0.0'})

            try:
                tree.write(cfg_xml, encoding='utf-8', xml_declaration=True)
                self.logger.log("Sanitized config.xml for Cordova build", "SUCCESS")
            except Exception:
                pass
        except Exception as e:
            self.logger.log("Warning: Failed to sanitize config.xml: {error}", "WARNING", error=str(e))
    def _fix_android_manifest_permissions(self, proj):
        """Исправляет AndroidManifest.xml, заменяя ns0:name -> android:name и добавляя xmlns:android при необходимости."""
        try:
            manifest_path = os.path.join(proj, 'platforms', 'android', 'app', 'src', 'main', 'AndroidManifest.xml')
            if not os.path.exists(manifest_path):
                return
            with open(manifest_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            changed = False
            # Универсально заменяем любые префиксы attr:name на android:name
            import re
            content_new = re.sub(r'\b([a-zA-Z0-9_]+):name=', 'android:name=', content)
            if content_new != content:
                content = content_new
                changed = True
            # Подстраховка: заменяем все вхождения ns0: на android:
            if 'ns0:' in content:
                content = content.replace('ns0:', 'android:')
                changed = True
            if 'xmlns:android=' not in content:
                content_new = re.sub(r'(<manifest\b[^>]*?)>', r'\1 xmlns:android="http://schemas.android.com/apk/res/android">', content, 1)
                if content_new != content:
                    content = content_new
                    changed = True
            if changed:
                with open(manifest_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                self.logger.log("Patched AndroidManifest.xml to fix permission namespaces", "SUCCESS")
        except Exception as e:
            self.logger.log("Warning: Failed to patch AndroidManifest.xml: {error}", "WARNING", error=str(e))

    def _ensure_splash_icon_config(self, proj, icon_img=None, splash_img=None, cfg=None):
        """Ensure files and config.xml are aligned to use www/icons/icon-128.png and icon-129.png."""
        try:
            # Ensure target files exist by copying from available sources
            www_icons = os.path.join(proj, 'www', 'icons')
            os.makedirs(www_icons, exist_ok=True)
            # Handle icon image if provided
            if icon_img and Image:
                try:
                    # Save icon as icon-129.png
                    icon_path = os.path.join(www_icons, 'icon-129.png')
                    icon_img.resize((129, 129), Image.Resampling.LANCZOS).save(icon_path, format="PNG")
                    self.logger.log("Saved icon as icon-129.png", "SUCCESS")
                except Exception as e:
                    self.logger.log("Warning: Failed to save icon: {error}", "WARNING", error=str(e))
            
            # Handle splash image if provided
            if splash_img and Image:
                try:
                    # Save splash as icon-128.png
                    splash_path = os.path.join(www_icons, 'icon-128.png')
                    splash_img.resize((128, 128), Image.Resampling.LANCZOS).save(splash_path, format="PNG")
                    self.logger.log("Saved splash as icon-128.png", "SUCCESS")
                except Exception as e:
                    self.logger.log("Warning: Failed to save splash: {error}", "WARNING", error=str(e))
            
            # pick a source for icon (prefer resources/icon.png, fallback to existing in www/icons)
            candidates_icon = [
                os.path.join(proj, 'resources', 'icon.png'),
                os.path.join(www_icons, 'icon-129.png'),
                os.path.join(proj, 'icon.png')
            ]
            src_icon = next((p for p in candidates_icon if os.path.exists(p)), None)
            if src_icon and not (icon_img and Image):
                try:
                    shutil.copyfile(src_icon, os.path.join(www_icons, 'icon-129.png'))
                except Exception:
                    pass
            # pick a source for splash (prefer resources/splash.png, fallback to existing in www/icons)
            candidates_splash = [
                os.path.join(proj, 'resources', 'splash.png'),
                os.path.join(www_icons, 'icon-128.png'),
                os.path.join(proj, 'splash_128.png')
            ]
            src_splash = next((p for p in candidates_splash if os.path.exists(p)), None)
            if src_splash and not (splash_img and Image):
                try:
                    shutil.copyfile(src_splash, os.path.join(www_icons, 'icon-128.png'))
                except Exception:
                    pass
            # edit config.xml
            cfg_xml = os.path.join(proj, 'config.xml')
            import xml.etree.ElementTree as ET
            if os.path.exists(cfg_xml):
                try:
                    tree = ET.parse(cfg_xml)
                    root = tree.getroot()
                except Exception:
                    root = ET.Element('widget')
                    tree = ET.ElementTree(root)
            else:
                root = ET.Element('widget')
                tree = ET.ElementTree(root)
            # strip namespaces from all tags to avoid ns0:widget issue
            def _strip_ns(elem):
                if '}' in elem.tag:
                    elem.tag = elem.tag.split('}', 1)[1]
                if ':' in elem.tag:
                    elem.tag = elem.tag.split(':', 1)[-1]
                for child in list(elem):
                    _strip_ns(child)
            _strip_ns(root)
            # ensure root tag is exactly 'widget'
            if root.tag != 'widget':
                new_root = ET.Element('widget')
                # move children
                for child in list(root):
                    new_root.append(child)
                # copy attributes except xmlns* to avoid namespace reintroduction
                for k, v in list(root.attrib.items()):
                    if not k.startswith('xmlns'):
                        new_root.set(k, v)
                root = new_root
                tree._setroot(root)
            # helpers
            def set_pref(name, value):
                for pref in root.findall('preference'):
                    if pref.get('name') == name:
                        pref.set('value', value)
                        return
                p = ET.SubElement(root, 'preference')
                p.set('name', name)
                p.set('value', value)
            # core prefs per working example
            set_pref('AndroidWindowSplashScreenAnimatedIcon', 'www/icons/icon-128.png')
            if cfg and 'splashColor' in cfg:
                set_pref('AndroidWindowSplashScreenBackground', cfg['splashColor'])
                set_pref('SplashScreenBackgroundColor', cfg['splashColor'])
            else:
                set_pref('AndroidWindowSplashScreenBackground', '#ffffff')
                set_pref('SplashScreenBackgroundColor', '#ffffff')
            # root icon
            has_root_icon = False
            for ic in root.findall('icon'):
                ic.set('src', 'www/icons/icon-129.png')
                ic.set('width', '272')
                ic.set('height', '272')
                ic.set('density', 'xxxhdpi')
                has_root_icon = True
            if not has_root_icon:
                ET.SubElement(root, 'icon', {'src': 'www/icons/icon-129.png', 'width': '272', 'height': '272', 'density': 'xxxhdpi'})
            # platform android
            plat = None
            for p in root.findall('platform'):
                if p.get('name') == 'android':
                    plat = p
                    break
            if plat is None:
                plat = ET.SubElement(root, 'platform')
                plat.set('name', 'android')
            # удаляем устаревший splash и больше не добавляем
            for sp in list(plat.findall('splash')):
                plat.remove(sp)
            # write
            try:
                tree.write(cfg_xml, encoding='utf-8', xml_declaration=True)
            except Exception:
                pass
        except Exception:
            pass

    def _on_closing(self):
        kill_processes_by_name("java")
        kill_processes_by_name("node")
        kill_processes_by_name("gradle")
        try:
            self.destroy()
        except Exception:
            pass

class WelcomeDialog(ctk.CTkToplevel):
    def __init__(self, parent, callback):
        super().__init__(parent)
        self.callback = callback
        self.result = None
        
        # Настройка окна
        self.title("Welcome to Saturn Builder")
        self.geometry("650x650")
        self.resizable(False, False)
        self.protocol("WM_DELETE_WINDOW", self.on_close)
        
        # Центрируем окно
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (650 // 2)
        y = (self.winfo_screenheight() // 2) - (650 // 2)
        self.geometry(f"650x650+{x}+{y}")
        
        # Создаем интерфейс
        self._build_ui()
        
        # Делаем окно модальным
        self.transient(parent)
        self.grab_set()
        self.focus_set()
        
        # Set icon AFTER all widgets are created to prevent interference
        set_window_icon(self)
        
    def _build_ui(self):
        # Основной контейнер
        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Заголовок
        title_label = ctk.CTkLabel(
            main_frame, 
            text="Welcome to Saturn Builder", 
            font=ctk.CTkFont(size=24, weight="bold")
        )
        title_label.pack(pady=(15, 8))
        
        # Подзаголовок
        subtitle_label = ctk.CTkLabel(
            main_frame, 
            text="Your complete solution for building Android applications",
            font=ctk.CTkFont(size=14),
            text_color="gray"
        )
        subtitle_label.pack(pady=(0, 20))
        
        # Место для изображения
        image_frame = ctk.CTkFrame(main_frame, height=120, fg_color="transparent")
        image_frame.pack(fill="x", padx=50, pady=(0, 20))
        image_frame.pack_propagate(False)
        
        # Загружаем и отображаем иконку из BASE64
        try:
            if Image and ImageTk:
                # Загружаем изображение из встроенной BASE64 строки
                import base64
                import io
                
                # Декодируем BASE64 и создаем изображение
                icon_data = base64.b64decode(base64_string.strip())
                img = Image.open(io.BytesIO(icon_data))
                
                # Изменяем размер для отображения (примерно 100x100)
                img = img.resize((100, 100), Image.Resampling.LANCZOS)
                # Конвертируем для tkinter
                photo = ImageTk.PhotoImage(img)
                
                # Создаем label с изображением
                image_label = ctk.CTkLabel(
                    image_frame,
                    image=photo,
                    text=""
                )
                image_label.image = photo  # Сохраняем ссылку
                image_label.pack(expand=True)
            else:
                # Если PIL не установлен, показываем заглушку
                image_placeholder = ctk.CTkLabel(
                    image_frame,
                    text="[PIL not available]\n\nCannot load icon",
                    font=ctk.CTkFont(size=12),
                    text_color="gray"
                )
                image_placeholder.pack(expand=True)
        except Exception as e:
            # В случае ошибки показываем заглушку
            image_placeholder = ctk.CTkLabel(
                image_frame,
                text=f"[Error loading icon]\n\n{str(e)}",
                font=ctk.CTkFont(size=12),
                text_color="gray"
            )
            image_placeholder.pack(expand=True)
        
        # Информация о зависимостях
        info_frame = ctk.CTkFrame(main_frame)
        info_frame.pack(fill="x", padx=20, pady=(0, 15))
        
        info_label = ctk.CTkLabel(
            info_frame,
            text="Dependencies Installation Required",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        info_label.pack(pady=(12, 8))
        
        deps_text = """Saturn Builder requires several dependencies to function properly:

• Node.js (JavaScript runtime)
• JDK 17 (Java Development Kit)
• Android SDK (Android development tools)
• Gradle (Build system)
• Cordova CLI (Mobile app framework)

Total download size: ~1GB

These dependencies will be downloaded and installed automatically to the 'dependencies' folder in the application directory."""
        
        deps_label = ctk.CTkLabel(
            info_frame,
            text=deps_text,
            font=ctk.CTkFont(size=12),
            justify="left",
            wraplength=500
        )
        deps_label.pack(padx=20, pady=(0, 12))
        
        # Кнопки
        button_frame = ctk.CTkFrame(main_frame)
        button_frame.pack(fill="x", padx=20, pady=(0, 15))
        
        # Кнопка "Install Dependencies"
        install_btn = ctk.CTkButton(
            button_frame,
            text="Install Dependencies",
            font=ctk.CTkFont(size=14, weight="bold"),
            fg_color="#2ecc71",
            hover_color="#27ae60",
            height=35,
            command=self.install_dependencies
        )
        install_btn.pack(side="left", padx=(0, 10), expand=True)
        
        # Кнопка "Skip for Now"
        skip_btn = ctk.CTkButton(
            button_frame,
            text="Skip for Now",
            font=ctk.CTkFont(size=14),
            fg_color="transparent",
            border_width=2,
            border_color="#666",
            height=35,
            command=self.skip_installation
        )
        skip_btn.pack(side="left", padx=(10, 0), expand=True)
        
    def install_dependencies(self):
        self.result = "install"
        self.destroy()
        if self.callback:
            self.callback("install")
            
    def skip_installation(self):
        self.result = "skip"
        self.destroy()
        if self.callback:
            self.callback("skip")
            
    def on_close(self):
        self.result = "skip"
        self.destroy()
        if self.callback:
            self.callback("skip")

class CoffeeSupportDialog(ctk.CTkToplevel):
    def __init__(self, parent, lang='en'):
        super().__init__(parent)
        
        self.lang = lang
        
        # Настройка окна
        self.title("Support Development" if lang == 'en' else "Поддержать разработку")
        self.geometry("600x600")  # Делаем окно больше
        self.resizable(False, False)
        
        # Центрируем окно
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (600 // 2)
        y = (self.winfo_screenheight() // 2) - (600 // 2)
        self.geometry(f"600x600+{x}+{y}")
        
        # Создаем интерфейс
        self._build_ui()
        
        # Делаем окно неблокирующим
        self.transient(parent)
        self.focus_set()
        
        # Set icon AFTER all widgets are created to prevent interference
        set_window_icon(self)
        
        # Добавляем обработчик закрытия окна
        self.protocol("WM_DELETE_WINDOW", self._on_closing)
        
    def _build_ui(self):
        # Основной контейнер
        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Заголовок
        title_text = "Support Development" if self.lang == 'en' else "Поддержать разработку"
        title_label = ctk.CTkLabel(
            main_frame,
            text=title_text,
            font=ctk.CTkFont(size=18, weight="bold")
        )
        title_label.pack(pady=(20, 15))
        
        # QR-код изображение с анимацией точек
        qr_frame = ctk.CTkFrame(main_frame)
        qr_frame.pack(pady=(0, 20))
        
        # Создаем canvas для анимации точек на заднем плане
        self.animation_canvas = tk.Canvas(
            qr_frame,
            width=240,
            height=240,
            bg='#2b2b2b',  # Темный фон вместо transparent
            highlightthickness=0
        )
        self.animation_canvas.place(relx=0.5, rely=0.5, anchor="center")
        
        try:
            if Image and ImageTk:
                # Загружаем QR-код из BASE64
                import base64
                import io
                
                # Декодируем BASE64 и создаем изображение
                qr_data = base64.b64decode(base64_qrico.strip())
                qr_img = Image.open(io.BytesIO(qr_data))
                
                # Изменяем размер для отображения (примерно 200x200)
                qr_img = qr_img.resize((200, 200), Image.Resampling.LANCZOS)
                # Конвертируем для tkinter
                qr_photo = ImageTk.PhotoImage(qr_img)
                
                # Создаем label с QR-кодом поверх canvas
                qr_label = ctk.CTkLabel(
                    qr_frame,
                    image=qr_photo,
                    text=""
                )
                qr_label.image = qr_photo  # Сохраняем ссылку
                qr_label.pack(padx=20, pady=20)
                
                # Запускаем анимацию точек
                self._start_particle_animation()
            else:
                # Если PIL не установлен, показываем заглушку
                qr_placeholder = ctk.CTkLabel(
                    qr_frame,
                    text="[QR Code]\n\nPIL not available",
                    font=ctk.CTkFont(size=12),
                    text_color="gray"
                )
                qr_placeholder.pack(padx=20, pady=20)
        except Exception as e:
            # В случае ошибки показываем заглушку
            qr_placeholder = ctk.CTkLabel(
                qr_frame,
                text=f"[QR Code Error]\n\n{str(e)}",
                font=ctk.CTkFont(size=12),
                text_color="gray"
            )
            qr_placeholder.pack(padx=20, pady=20)
        
        # Текст поддержки
        support_text_en = """Thank you for using our app! 

If you find it helpful, please consider supporting the development by buying me a coffee. 😊

Your support helps keep the project alive and enables new features."""
        
        support_text_ru = """Спасибо за использование нашего приложения!

Если оно вам помогло, пожалуйста, рассмотрите возможность поддержать разработку, купив мне кофе. 😊

Ваша поддержка помогает проекту развиваться и добавлять новые функции."""
        
        support_text = support_text_en if self.lang == 'en' else support_text_ru
        
        support_label = ctk.CTkLabel(
            main_frame,
            text=support_text,
            font=ctk.CTkFont(size=12),
            justify="center",
            wraplength=350
        )
        support_label.pack(padx=20, pady=(0, 20))
        
        # Кнопка поддержки разработчика
        support_text = "Support Developer" if self.lang == 'en' else "Поддержать разработчика"
        support_btn = ctk.CTkButton(
            main_frame,
            text=support_text,
            font=ctk.CTkFont(size=12, weight="bold"),
            width=120,
            height=40,
            fg_color="#1f538d",  # Синий цвет
            hover_color="#2d6bb8",  # Более светлый синий при наведении
            corner_radius=8,  # Делаем углы более квадратными
            command=self._open_support_link
        )
        support_btn.pack(pady=(0, 10))
        
        # Кнопка закрытия
        close_text = "Close" if self.lang == 'en' else "Закрыть"
        close_btn = ctk.CTkButton(
            main_frame,
            text=close_text,
            font=ctk.CTkFont(size=12, weight="bold"),
            width=100,
            height=30,
            command=self.destroy
        )
        close_btn.pack(pady=(0, 20))
    
    def _on_closing(self):
        """Обработчик закрытия окна"""
        try:
            self.destroy()
        except Exception:
            pass
    
    def _open_support_link(self):
        """Открывает ссылку на страницу поддержки разработчика"""
        try:
            import webbrowser
            support_url = "https://www.donationalerts.com/r/ewenloy"
            webbrowser.open(support_url)
        except Exception as e:
            # В случае ошибки показываем сообщение пользователю
            error_text = f"Failed to open link: {str(e)}" if self.lang == 'en' else f"Не удалось открыть ссылку: {str(e)}"
            messagebox.showerror(
                "Error" if self.lang == 'en' else "Ошибка",
                error_text
            )
    
    def _start_particle_animation(self):
        """Запускает анимацию белых точек по спирали вокруг QR-кода"""
        import math
        import random
        
        # Список для хранения частиц
        self.particles = []
        
        def create_particle():
            """Создает новую белую точку"""
            # Случайная позиция по кругу вокруг центра
            center_x, center_y = 120, 120
            radius = random.uniform(60, 100)  # Начальный радиус
            angle = random.uniform(0, 2 * math.pi)
            
            x = center_x + radius * math.cos(angle)
            y = center_y + radius * math.sin(angle)
            
            # Спиральное движение с более плавными параметрами
            spiral_speed = random.uniform(0.01, 0.03)  # Более медленное закручивание
            outward_speed = random.uniform(0.2, 0.5)   # Более медленное удаление
            
            # Случайный размер от 1 до 4 пикселей
            size = random.uniform(1, 4)
            
            # Создаем точку на canvas
            particle_id = self.animation_canvas.create_oval(
                x-size, y-size, x+size, y+size,
                fill='white', outline='white', tags="particle"
            )
            
            # Сохраняем данные частицы
            particle_data = {
                'id': particle_id,
                'x': x,
                'y': y,
                'center_x': center_x,
                'center_y': center_y,
                'radius': radius,
                'angle': angle,
                'spiral_speed': spiral_speed,
                'outward_speed': outward_speed,
                'size': size,
                'alpha': 1.0,  # Начальная прозрачность 100%
                'fade_speed': random.uniform(0.003, 0.008),  # Более медленное затухание
                'size_change_speed': random.uniform(0.01, 0.03),  # Скорость изменения размера
                'target_size': size * random.uniform(0.5, 1.0)  # Целевой размер (50-100% от исходного)
            }
            
            self.particles.append(particle_data)
        
        def animate_particles():
            """Анимирует все частицы по спирали с плавным изменением размера"""
            # Создаем новые частицы случайно
            if random.random() < 0.25:  # 25% шанс создания новой частицы
                create_particle()
            
            # Обновляем существующие частицы
            particles_to_remove = []
            for particle in self.particles:
                # Обновляем угол для спирального движения
                particle['angle'] += particle['spiral_speed']
                
                # Увеличиваем радиус для удаления от центра
                particle['radius'] += particle['outward_speed']
                
                # Уменьшаем прозрачность
                particle['alpha'] -= particle['fade_speed']
                
                # Плавно изменяем размер частицы
                if particle['size'] > particle['target_size']:
                    particle['size'] -= particle['size_change_speed']
                elif particle['size'] < particle['target_size']:
                    particle['size'] += particle['size_change_speed']
                
                # Вычисляем новую позицию
                x = particle['center_x'] + particle['radius'] * math.cos(particle['angle'])
                y = particle['center_y'] + particle['radius'] * math.sin(particle['angle'])
                
                # Удаляем частицы, которые стали полностью прозрачными или улетели слишком далеко
                if particle['alpha'] <= 0 or particle['radius'] > 250:
                    self.animation_canvas.delete(particle['id'])
                    particles_to_remove.append(particle)
                else:
                    # Обновляем позицию и размер частицы
                    self.animation_canvas.coords(
                        particle['id'],
                        x - particle['size'],
                        y - particle['size'],
                        x + particle['size'],
                        y + particle['size']
                    )
                    
                    # Изменяем цвет в зависимости от прозрачности
                    if particle['alpha'] > 0.7:
                        # Белый (100-70% прозрачности)
                        self.animation_canvas.itemconfig(particle['id'], fill='white', outline='white')
                    elif particle['alpha'] > 0.4:
                        # Светло-серый (70-40% прозрачности)
                        self.animation_canvas.itemconfig(particle['id'], fill='lightgray', outline='lightgray')
                    elif particle['alpha'] > 0.1:
                        # Серый (40-10% прозрачности)
                        self.animation_canvas.itemconfig(particle['id'], fill='gray', outline='gray')
                    else:
                        # Темно-серый (10-0% прозрачности)
                        self.animation_canvas.itemconfig(particle['id'], fill='darkgray', outline='darkgray')
            
            # Удаляем частицы из списка
            for particle in particles_to_remove:
                if particle in self.particles:
                    self.particles.remove(particle)
            
            # Продолжаем анимацию с более высокой частотой для плавности
            self.after(20, animate_particles)  # ~50 FPS для более плавной анимации
        
        # Запускаем анимацию
        animate_particles()

class SkipDependenciesDialog(ctk.CTkToplevel):
    def __init__(self, parent):
        super().__init__(parent)
        
        # Настройка окна
        self.title("Dependencies Not Installed")
        self.geometry("500x300")
        self.resizable(False, False)
        
        # Центрируем окно
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (500 // 2)
        y = (self.winfo_screenheight() // 2) - (300 // 2)
        self.geometry(f"500x300+{x}+{y}")
        # Создаем интерфейс
        self._build_ui()
        
        # Делаем окно модальным
        self.transient(parent)
        self.grab_set()
        self.focus_set()
        
        # Set icon AFTER all widgets are created to prevent interference
        set_window_icon(self)
        
    def _build_ui(self):
        # Основной контейнер
        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Иконка предупреждения
        warning_label = ctk.CTkLabel(
            main_frame,
            text="⚠️",
            font=ctk.CTkFont(size=48)
        )
        warning_label.pack(pady=(20, 10))
        
        # Заголовок
        title_label = ctk.CTkLabel(
            main_frame,
            text="Dependencies Not Installed",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        title_label.pack(pady=(0, 15))
        
        # Сообщение
        message_text = """You can install dependencies later by clicking the "re-check deps" button in the Manual Actions section.

Without dependencies, you won't be able to build projects, but you can still explore the application interface."""
        
        message_label = ctk.CTkLabel(
            main_frame,
            text=message_text,
            font=ctk.CTkFont(size=12),
            justify="left",
            wraplength=400
        )
        message_label.pack(padx=20, pady=(0, 20))
        
        # Кнопка OK
        ok_btn = ctk.CTkButton(
            main_frame,
            text="OK",
            font=ctk.CTkFont(size=14, weight="bold"),
            width=120,
            height=35,
            command=self.destroy
        )
        ok_btn.pack(pady=(0, 20))

class Html5ConfigDialog(ctk.CTkToplevel):
    def __init__(self, parent, on_confirm):
        super().__init__(parent)
        self.parent = parent
        self.on_confirm = on_confirm
        # Если это Cordova-проект (есть config.xml), сразу закрываем диалог и переключаем тип
        try:
            proj = getattr(self.parent, 'project_path', None)
            if proj and os.path.exists(os.path.join(proj, 'config.xml')):
                try:
                    self.destroy()
                except Exception:
                    pass
                try:
                    self.parent.project_internal_var.set("Cordova")
                    self.parent.project_display_var.set(self.parent._localize_display("Cordova"))
                    self.parent._rebuild_optionmenus()
                    self.parent.btn_build.configure(state="normal")
                    # Прячем кнопки HTML5 конфигурации
                    try:
                        self.parent.btn_html5_config.pack_forget()
                        self.parent.btn_html5_config_top.pack_forget()
                    except Exception:
                        pass
                    self.parent.logger.log("Auto-switched to Cordova: config.xml detected; closed HTML5 settings", "SUCCESS")
                except Exception:
                    pass
                return
        except Exception:
            pass
        self.title(self.parent._tr("HTML5 App Settings"))
        self.geometry("780x700")
        self.resizable(False, False)
        self._icon_image = None
        self._icon_path = None
        # Splash state
        self._splash_image = None
        self._splash_path = None
        self.splash_color_var = tk.StringVar(value="#000000")
        # Position at the same coordinates as the main window
        try:
            self.update_idletasks()
            px = max(0, int(self.parent.winfo_x()))
            py = max(0, int(self.parent.winfo_y()))
            self.geometry(f"780x700+{px}+{py}")
        except Exception:
            # Fallback to centered if parent coords not available
            x = (self.winfo_screenwidth() // 2) - (780 // 2)
            y = (self.winfo_screenheight() // 2) - (700 // 2)
            self.geometry(f"780x700+{x}+{y}")
        # UI
        self._build_ui()
        set_window_icon(self)
        # Поднимаем окно на передний план и фокусируем поверх родителя
        try:
            self.transient(self.parent)
            self.lift()
            self.focus_force()
            # Коротко делаем topmost, затем снимаем, чтобы не мешать другим окнам
            self.attributes('-topmost', True)
            self.after(200, lambda: self.attributes('-topmost', False))
            # Повторный подъем и фокус через небольшой интервал для надежности
            self.after(250, lambda: (self.lift(), self.focus_force()))
        except Exception:
            try:
                self.lift()
                self.focus_force()
            except Exception:
                pass
        # Не делаем modal grab, чтобы окно можно было свернуть

    def _build_ui(self):
        pad = 10
        root = ctk.CTkFrame(self)
        root.pack(fill="both", expand=True, padx=16, pady=16)

        header = ctk.CTkLabel(root, text=self.parent._tr("Configure HTML5 App"), font=ctk.CTkFont(size=18, weight="bold"))
        header.pack(anchor="w", pady=(0, 10))

        body = ctk.CTkFrame(root)
        body.pack(fill="both", expand=True)

        left = ctk.CTkFrame(body)
        left.pack(side="left", fill="y", padx=(0, 8), pady=8)
        # Прокручиваемая правая часть
        right = ctk.CTkScrollableFrame(body)
        right.pack(side="left", fill="both", expand=True, padx=(8, 0), pady=8)

        # Icon selector with preview
        ctk.CTkLabel(left, text=self.parent._tr("App Icon"), font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", padx=pad, pady=(pad, 4))
        self.icon_preview = ctk.CTkLabel(left, text="128x128", width=160, height=160, fg_color="#1f1f1f")
        self.icon_preview.pack(padx=pad, pady=(0, 8))
        ctk.CTkButton(left, text=self.parent._tr("Upload Icon"), command=self._choose_icon).pack(padx=pad, pady=(0, 8))
        # Default preview from embedded base64_qrico
        try:
            if Image and ImageTk and isinstance(base64_qrico, str) and base64_qrico:
                import base64, io
                _data = base64.b64decode(base64_qrico.strip())
                _img = Image.open(io.BytesIO(_data)).convert("RGBA")
                _img = _img.resize((128, 128), Image.Resampling.LANCZOS)
                _photo = ImageTk.PhotoImage(_img)
                self.icon_preview.configure(image=_photo, text="")
                self.icon_preview.image = _photo
                self._icon_image = _img
        except Exception:
            pass

        # Splash selector with preview
        ctk.CTkLabel(left, text=self.parent._tr("Splash Icon"), font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", padx=pad, pady=(pad, 4))
        self.splash_preview = ctk.CTkLabel(left, text="128x128", width=160, height=160, fg_color="#1f1f1f")
        self.splash_preview.pack(padx=pad, pady=(0, 8))
        ctk.CTkButton(left, text=self.parent._tr("Upload Splash"), command=self._choose_splash).pack(padx=pad, pady=(0, 8))

        # General settings
        blk = ctk.CTkFrame(right)
        blk.pack(fill="x", padx=pad, pady=(pad, 6))
        ctk.CTkLabel(blk, text=self.parent._tr("General"), font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", padx=8, pady=(8, 6))

        form = ctk.CTkFrame(blk)
        form.pack(fill="x", padx=8, pady=(0, 8))

        def row(label):
            fr = ctk.CTkFrame(form)
            fr.pack(fill="x", pady=4)
            ctk.CTkLabel(fr, text=label, width=160, anchor="w").pack(side="left")
            ent = ctk.CTkEntry(fr)
            ent.pack(side="left", fill="x", expand=True)
            return ent

        self.f_id = row(self.parent._tr("App ID (e.g., com.app.id)"))
        self.f_id.insert(0, "COM.COMPANY.NAME")
        self.f_name = row(self.parent._tr("App Name"))
        self.f_name.insert(0, "Smart Home Assistant")
        self.f_desc = row(self.parent._tr("Description"))
        self.f_desc.insert(0, "MADE WITH SATURN BUILDER! FREE FOR EVERYONE")
        self.f_version = row(self.parent._tr("Version (x.y.z)"))
        self.f_version.insert(0, "1.0.0.0")
        self.f_version_code = row(self.parent._tr("Android version code"))
        self.f_version_code.insert(0, "1000000")
        self.f_author = row(self.parent._tr("Author"))
        self.f_author.insert(0, "EWENLOY")
        self.f_email = row(self.parent._tr("Email"))
        self.f_email.insert(0, "EWENLOY@GMAIL.COM")
        self.f_website = row(self.parent._tr("Website"))
        self.f_website.insert(0, "https://github.com/EwenLoy/Saturn-Builder/")

        # Min/Target versions & properties
        props = ctk.CTkFrame(right)
        props.pack(fill="x", padx=pad, pady=(6, 6))
        ctk.CTkLabel(props, text=self.parent._tr("Android Versions"), font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", padx=8, pady=(8, 6))

        versions = [
            ("7.0+ (Nougat)", "24"), ("8.0+ (Oreo)", "26"), ("9.0+ (Pie)", "28"),
            ("10+ (Q)", "29"), ("11+ (R)", "30"), ("12+ (S)", "31"), ("13+ (T)", "33"), ("14+ (U)", "34")
        ]
        self.min_display = tk.StringVar(value=versions[0][0])
        self.min_value = versions[0][1]
        def on_min_change(val):
            for d,v in versions:
                if d == val:
                    self.min_value = v
                    break
        rowv = ctk.CTkFrame(props)
        rowv.pack(fill="x", pady=4)
        ctk.CTkLabel(rowv, text=self.parent._tr("Min. version"), width=160, anchor="w").pack(side="left")
        ctk.CTkOptionMenu(rowv, values=[d for d,_ in versions], variable=self.min_display, command=on_min_change, width=220).pack(side="left")
        #ctk.CTkLabel(props, text=self.parent._tr("Target version: Android 14 (API level 34)")).pack(anchor="w", padx=8, pady=(4, 8))

        # Properties (whitelist, toggles)
        ctk.CTkLabel(props, text=self.parent._tr("Properties"), font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", padx=8, pady=(8, 6))
        prow = ctk.CTkFrame(props)
        prow.pack(fill="x", pady=4)
        ctk.CTkLabel(prow, text=self.parent._tr("URL whitelist"), width=160, anchor="w").pack(side="left")
        self.f_whitelist = ctk.CTkEntry(prow)
        self.f_whitelist.insert(0, "http://*/* https://*/*")
        self.f_whitelist.pack(side="left", fill="x", expand=True)

        # toggles
        self.chk_hide_status = tk.BooleanVar(value=False)
        self.chk_vibrate = tk.BooleanVar(value=False)
        self.chk_camera = tk.BooleanVar(value=False)
        self.chk_microphone = tk.BooleanVar(value=False)
        toggles = ctk.CTkFrame(props)
        toggles.pack(fill="x", pady=6)
        ctk.CTkCheckBox(toggles, text=self.parent._tr("Hide status bar"), variable=self.chk_hide_status).pack(anchor="w")
        ctk.CTkCheckBox(toggles, text=self.parent._tr("Require Vibrate permission"), variable=self.chk_vibrate).pack(anchor="w")
        ctk.CTkCheckBox(toggles, text=self.parent._tr("Require Camera permission"), variable=self.chk_camera).pack(anchor="w")
        ctk.CTkCheckBox(toggles, text=self.parent._tr("Require Microphone permission"), variable=self.chk_microphone).pack(anchor="w")

        # Orientation
        orient_blk = ctk.CTkFrame(right)
        orient_blk.pack(fill="x", padx=pad, pady=(6, 6))
        ctk.CTkLabel(orient_blk, text=self.parent._tr("Orientation"), font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", padx=8, pady=(8, 6))
        self.orientation = tk.StringVar(value="portrait")
        orow = ctk.CTkFrame(orient_blk)
        orow.pack(fill="x", pady=4)
        ctk.CTkRadioButton(orow, text=self.parent._tr("Portrait"), variable=self.orientation, value="portrait").pack(side="left", padx=8)
        ctk.CTkRadioButton(orow, text=self.parent._tr("Landscape"), variable=self.orientation, value="landscape").pack(side="left", padx=8)

        # Splash Screen settings (color selection removed from UI per request)
        #splash_blk = ctk.CTkFrame(right)
        #splash_blk.pack(fill="x", padx=pad, pady=(6, 6))
        #ctk.CTkLabel(splash_blk, text=self.parent._tr("Splash Screen"), font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", padx=8, pady=(8, 6))

        # Footer buttons
        footer = ctk.CTkFrame(root)
        footer.pack(fill="x", padx=pad, pady=(8, 0))
        ctk.CTkButton(footer, text=self.parent._tr("Cancel"), command=self.destroy, width=120).pack(side="right", padx=6)
        ctk.CTkButton(footer, text=self.parent._tr("Confirm"), command=self._confirm, width=160, fg_color="#2ecc71", hover_color="#27ae60").pack(side="right", padx=6)

    def _choose_icon(self):
        path = filedialog.askopenfilename(title=self.parent._tr("Select icon image"), filetypes=[("Images", "*.png;*.jpg;*.jpeg;*.ico"), ("All files", "*.*")])
        if not path:
            return
        try:
            if Image and ImageTk:
                img = Image.open(path)
                img = img.resize((128, 128), Image.Resampling.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                self.icon_preview.configure(image=photo, text="")
                self.icon_preview.image = photo
                self._icon_image = img
                self._icon_path = path
                # Вернуть окно настроек на передний план после выбора файла
                try:
                    self.lift()
                    self.focus_force()
                    self.attributes('-topmost', True)
                    self.after(200, lambda: self.attributes('-topmost', False))
                except Exception:
                    pass
        except Exception:
            pass

    def _choose_splash(self):
        path = filedialog.askopenfilename(title=self.parent._tr("Select splash image"), filetypes=[("Images", "*.png;*.jpg;*.jpeg;*.ico"), ("All files", "*.*")])
        if not path:
            return
        try:
            if Image and ImageTk:
                img = Image.open(path)
                img = img.resize((128, 128), Image.Resampling.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                self.splash_preview.configure(image=photo, text="")
                self.splash_preview.image = photo
                self._splash_image = img
                self._splash_path = path
                try:
                    self.lift()
                    self.focus_force()
                    self.attributes('-topmost', True)
                    self.after(200, lambda: self.attributes('-topmost', False))
                except Exception:
                    pass
        except Exception:
            pass

    def _pick_splash_color(self):
        try:
            from tkinter import colorchooser
            color = colorchooser.askcolor(color=self.splash_color_var.get() or "#000000")
            if color and color[1]:
                self.splash_color_var.set(color[1])
        except Exception:
            pass

    def _confirm(self):
        data = {
            "id": self.f_id.get().strip() or "com.example.app",
            "name": self.f_name.get().strip() or "My App",
            "description": self.f_desc.get().strip() or "",
            "version": self.f_version.get().strip() or "1.0.0",
            "versionCode": self.f_version_code.get().strip() or "1",
            "author": self.f_author.get().strip() or "",
            "email": self.f_email.get().strip() or "",
            "website": self.f_website.get().strip() or "",
            "whitelist": self.f_whitelist.get().strip() or "http://*/* https://*/*",
            "minApi": self.parent._safe_min_api(self.min_value),
            "targetApi": "34",
            "orientation": self.orientation.get(),
            "hideStatus": self.chk_hide_status.get(),
            "permVibrate": self.chk_vibrate.get(),
            "permCamera": self.chk_camera.get(),
            "permMic": self.chk_microphone.get(),
            "iconPath": self._icon_path,
            "splashIconPath": self._splash_path,
            "splashColor": self.splash_color_var.get() or "#000000"
        }
        try:
            # Apply to config files immediately
            try:
                self._apply_to_configs(data)
            except Exception:
                pass
            # Call parent callback
            self.on_confirm(data, self._icon_image)
        finally:
            self.destroy()

    def _apply_to_configs(self, data):
        try:
            proj = getattr(self.parent, 'project_path', None)
            if not proj:
                return
            # Save images into project
            if self._icon_image is not None:
                try:
                    icon_out = os.path.join(proj, 'icon_128.png')
                    self._icon_image.save(icon_out, format='PNG')
                    # also save common Cordova root icon name so generator can pick it
                    icon_root = os.path.join(proj, 'icon.png')
                    self._icon_image.save(icon_root, format='PNG')
                    # also save into resources/ for cordova-res
                    res_dir = os.path.join(proj, 'resources')
                    try:
                        os.makedirs(res_dir, exist_ok=True)
                        self._icon_image.save(os.path.join(res_dir, 'icon.png'), format='PNG')
                    except Exception:
                        pass
                    # also save into www/icons like working config
                    www_icons = os.path.join(proj, 'www', 'icons')
                    try:
                        os.makedirs(www_icons, exist_ok=True)
                        # save as icon-128.png and icon-129.png for compatibility
                        self._icon_image.save(os.path.join(www_icons, 'icon-128.png'), format='PNG')
                        self._icon_image.save(os.path.join(www_icons, 'icon-129.png'), format='PNG')
                    except Exception:
                        pass
                except Exception:
                    pass
            # If splash not selected, fallback to app icon (base64_string of Saturn Builder icon)
            if self._splash_image is None:
                try:
                    if Image and isinstance(base64_string, str) and base64_string:
                        import base64, io
                        _data_fallback = base64.b64decode(base64_string.strip())
                        self._splash_image = Image.open(io.BytesIO(_data_fallback)).convert('RGBA')
                        self._splash_image = self._splash_image.resize((128, 128), Image.Resampling.LANCZOS)
                except Exception:
                    pass
            if self._splash_image is not None:
                try:
                    splash_out = os.path.join(proj, 'splash_128.png')
                    self._splash_image.save(splash_out, format='PNG')
                    # also save into resources/
                    res_dir = os.path.join(proj, 'resources')
                    try:
                        os.makedirs(res_dir, exist_ok=True)
                        self._splash_image.save(os.path.join(res_dir, 'splash.png'), format='PNG')
                    except Exception:
                        pass
                    # also save into www/icons (legacy) and www/res/drawable for Android 12 splash API
                    www_icons = os.path.join(proj, 'www', 'icons')
                    try:
                        os.makedirs(www_icons, exist_ok=True)
                        self._splash_image.save(os.path.join(www_icons, 'icon-128.png'), format='PNG')
                    except Exception:
                        pass
                    # place animated splash drawable where Android will resolve res://splash
                    www_res_drawable = os.path.join(proj, 'www', 'res', 'drawable')
                    try:
                        os.makedirs(www_res_drawable, exist_ok=True)
                        self._splash_image.save(os.path.join(www_res_drawable, 'splash.png'), format='PNG')
                    except Exception:
                        pass
                except Exception:
                    pass
            # Update config.json (create or merge)
            import json
            cfg_json_path = os.path.join(proj, 'config.json')
            cfg = {}
            if os.path.exists(cfg_json_path):
                try:
                    with open(cfg_json_path, 'r', encoding='utf-8') as f:
                        cfg = json.load(f)
                except Exception:
                    cfg = {}
            cfg.update({
                'id': data['id'],
                'name': data['name'],
                'description': data['description'],
                'version': data['version'],
                'versionCode': data['versionCode'],
                'author': data['author'],
                'email': data['email'],
                'website': data['website'],
                'whitelist': data['whitelist'],
                'minApi': data['minApi'],
                'targetApi': data['targetApi'],
                'orientation': data['orientation'],
                'hideStatus': data['hideStatus'],
                'permissions': {
                    'vibrate': data['permVibrate'],
                    'camera': data['permCamera'],
                    'microphone': data['permMic']
                },
                'icon': 'icon_128.png' if self._icon_image is not None else data.get('iconPath'),
                'splashIcon': 'splash_128.png' if self._splash_image is not None else data.get('splashIconPath'),
                'splashColor': data.get('splashColor')
            })
            with open(cfg_json_path, 'w', encoding='utf-8') as f:
                json.dump(cfg, f, indent=2, ensure_ascii=False)
            # Update config.xml (ensure splash color/preferences are set regardless of existence)
            cfg_xml_path = os.path.join(proj, 'config.xml')
            if os.path.exists(cfg_xml_path):
                import xml.etree.ElementTree as ET
                try:
                    tree = ET.parse(cfg_xml_path)
                    root = tree.getroot()
                except Exception:
                    # Create a minimal Cordova config if parsing fails
                    root = ET.Element('widget')
                    tree = ET.ElementTree(root)
            else:
                # create minimal config.xml if missing
                import xml.etree.ElementTree as ET
                root = ET.Element('widget')
                tree = ET.ElementTree(root)
            # helper to ensure preference (works for both newly created and existing config.xml)
            import xml.etree.ElementTree as ET
            def set_pref(name, value):
                for pref in root.findall("preference"):
                    if pref.get('name') == name:
                        pref.set('value', value)
                        return
                p = ET.SubElement(root, 'preference')
                p.set('name', name)
                p.set('value', value)

            # normalize color and ensure preferences are set/updated
            col = (data.get('splashColor') or '#000000')
            try:
                col = col.strip().upper()
            except Exception:
                col = '#000000'
            if not col.startswith('#'):
                col = '#' + col
            # Apply prefs for both new and existing configs (Android 12 compatible)
            set_pref('SplashScreenBackgroundColor', col)
            set_pref('AndroidWindowSplashScreenAnimatedIcon', 'www/icons/icon-128.png')
            set_pref('AndroidWindowSplashScreenBackground', col)
            set_pref('SplashMaintainAspectRatio', 'true')
            set_pref('ShowSplashScreenSpinner', 'false')
            # simple icon entries
            # root icon for all platforms
            # Update or add root-level <icon src="icon.png"/>
            root_icon_set = False
            for ic in root.findall('icon'):
                ic.set('src', 'www/icons/icon-129.png')
                root_icon_set = True
            if not root_icon_set:
                ET.SubElement(root, 'icon', {'src': 'www/icons/icon-129.png', 'width': '272', 'height': '272', 'density': 'xxxhdpi'})
            # Ensure <platform name="android"> exists
            plat = None
            for p in root.findall('platform'):
                if p.get('name') == 'android':
                    plat = p
                    break
            if plat is None:
                plat = ET.SubElement(root, 'platform')
                plat.set('name', 'android')
            # add icon and splash 128x128 as generic resources
            if self._icon_image is not None or data.get('iconPath'):
                # remove previous icons with src icon_128.png
                for ic in list(plat.findall('icon')):
                    if ic.get('src') in ('icon_128.png', 'res/icon/android/icon-96-mdpi.png'):
                        plat.remove(ic)
                ET.SubElement(plat, 'icon', {'src': 'www/icons/icon-129.png', 'width': '272', 'height': '272', 'density': 'xxxhdpi'})
            if self._splash_image is not None or data.get('splashIconPath'):
                # remove old splash nodes
                for sp in list(plat.findall('splash')):
                    plat.remove(sp)
                # ensure resource-file maps our www/res/drawable/splash.png into Android res
                for rf in list(plat.findall('resource-file')):
                    t = rf.get('target') or ''
                    if t.endswith('app/src/main/res/drawable/splash.png') or t.endswith('res/drawable/splash.png'):
                        plat.remove(rf)
                ET.SubElement(plat, 'resource-file', {
                    'src': 'www/res/drawable/splash.png',
                    'target': 'app/src/main/res/drawable/splash.png'
                })
            try:
                tree.write(cfg_xml_path, encoding='utf-8', xml_declaration=True)
            except Exception:
                pass
            # Mark that resources updated so next build refreshes platform
            try:
                import json
                marker = os.path.join(proj, '.cordova_assets.json')
                state = {}
                if os.path.exists(marker):
                    try:
                        with open(marker, 'r', encoding='utf-8') as f:
                            state = json.load(f)
                    except Exception:
                        state = {}
                state['pendingResourceUpdate'] = True
                with open(marker, 'w', encoding='utf-8') as f:
                    json.dump(state, f)
            except Exception:
                pass
        except Exception:
            pass

def set_window_icon(window):
    """Helper function to set icon for customtkinter windows using BASE64"""
    try:
        # Метод 1: Создание временного файла из BASE64 (основной метод для иконки окна)
        try:
            import base64
            import io
            import tempfile
            
            # Декодируем BASE64 и создаем временный файл
            icon_data = base64.b64decode(base64_string.strip())
            
            # Создаем временный файл
            with tempfile.NamedTemporaryFile(delete=False, suffix='.ico') as temp_file:
                temp_file.write(icon_data)
                temp_icon_path = temp_file.name
            
            # Устанавливаем иконку окна из временного файла
            window.iconbitmap(temp_icon_path)
            print("Successfully set window icon using temporary file from BASE64")
            
            # Store the temp file path for cleanup
            window._temp_icon_path = temp_icon_path
            
            # Cleanup function
            def cleanup_temp_file():
                try:
                    if hasattr(window, '_temp_icon_path') and os.path.exists(window._temp_icon_path):
                        os.unlink(window._temp_icon_path)
                        print(f"Cleaned up temp icon file: {window._temp_icon_path}")
                except Exception as e:
                    print(f"Cleanup failed: {e}")
            
            # Cleanup when window is destroyed
            window.protocol("WM_DELETE_WINDOW", lambda: [cleanup_temp_file(), window.destroy()])
            
            return True
            
        except Exception as e1:
            print(f"Temporary file method failed: {e1}")
        
        # Метод 2: PIL с BASE64 (fallback)
        try:
            if Image and ImageTk:
                import base64
                import io
                
                # Декодируем BASE64 и создаем изображение
                icon_data = base64.b64decode(base64_string.strip())
                img = Image.open(io.BytesIO(icon_data))
                
                # Создаем PhotoImage для иконки окна
                photo = ImageTk.PhotoImage(img)
                window.iconphoto(True, photo)
                print("Successfully set window icon using PIL with BASE64")
                
                # Store the photo reference to prevent garbage collection
                window._icon_photo = photo
                
                return True
            else:
                print("PIL not available")
        except Exception as e2:
            print(f"PIL with BASE64 failed: {e2}")
        
        return False
        
    except Exception as e:
        print(f"Error in set_window_icon: {e}")
        return False

def main():
    app = MainApp()
    try:
        app.mainloop()
    except Exception as e:
        print(f"Application error: {e}")
        sys.exit(1)
if __name__ == "__main__":
    main()
